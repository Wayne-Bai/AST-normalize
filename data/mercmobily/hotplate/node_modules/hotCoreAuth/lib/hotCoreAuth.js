"use strict";

var dummy
  , path = require('path')
  , hotplate = require('hotplate')
  , declare = require('simpledeclare')

  , SimpleDbLayer = require( 'simpledblayer' )
  , SimpleSchema = require( 'simpleschema' )
  , JsonRestStores = require( 'jsonreststores' )

  , hotCoreJsonRestStores = require( 'hotCoreJsonRestStores' )
  , hotCoreStoreRegistry = require( 'hotCoreStoreRegistry' )
  , hotCoreServerLogger = require( 'hotCoreServerLogger' )
;

/**
Provides authentication abilities to Hotplate

This module's goal is to do two things.

First of all , it defines all of the stores necessary for authentication. The stores in question are:

* Users. The list of users.
* UsersStrategies. The list of strategies set by that user.
* AuthStrategies. The complete list of auth strategies available
* Logins. A store that simply allows the search of username, used by Ajax to check if a username is already taken


@module hotCoreAuth
@main hotCoreAuth
@class hotCoreAuth
@static
*/

// Set some sane defaults

var basicResponsePage = function( strategyId, action, user, profile ){
  var response = '';
  response += "<html><body><script type=\"text/javascript\">setTimeout(function(){ window.close() }, 5000);</script>RESPONSE</body></html>";
  return response;
};



hotplate.config.set('hotCoreAuth', {

  callbackURLBase: 'http://localhost:3000',

  recoverURLexpiry: 60*30, // Seconds for which the recover URL works for

  // Only local strategy enabled by default
  strategies: {
    local: { },
  },

  redirectURLs: {
    success: {
      signin: path.join( hotplate.config.get( 'hotplate.routeUrlsPrefix' ), '/auth/pick' ),
      recover: path.join( hotplate.config.get( 'hotplate.routeUrlsPrefix' ), '/auth/pick'),
      register: path.join( hotplate.config.get( 'hotplate.routeUrlsPrefix' ),'/auth/pick'),
      manager: '/',
    },

    fail: {
      signin: path.join( hotplate.config.get( 'hotplate.routeUrlsPrefix' ), '/auth/welcome' ),
      recover: path.join( hotplate.config.get( 'hotplate.routeUrlsPrefix' ), '/auth/welcome' ),
      register: path.join( hotplate.config.get( 'hotplate.routeUrlsPrefix' ), '/auth/welcome' ),
      manager: '/',
    }
  },
  responsePage: basicResponsePage,
  appURL: path.join( hotplate.config.get( 'hotplate.routeUrlsPrefix' ), '/app' ),

});


/**
  Initialisation hook. It creates the basic authentication stores
  (Users, UsersStrategies, AuthStrategies, Logins) 

  @event init
  @requires hotCoreJsonRestStores
*/

hotplate.hotEvents.onCollect( 'stores', 'hotCoreAuth', hotplate.cachable( function( done ){

  var stores = {}

  hotCoreJsonRestStores.get( function( err, s ){
    if( err ){
      done( err );
    } else {

      var HotStore = s.HotStore;
      var HotSchema = s.HotSchema;

      // ***********************************
      // *** USERS *************************
      // ***********************************
    
      var Users = declare( HotStore, {
    
        // COMMON
        schema: new HotSchema({
          recoverToken:        { type: 'blob', searchable: true, notempty: true },
          recoverTokenCreated: { type: 'date', searchable: true, notempty: true },
        }),

        // Nothing is searchable in users by default
        onlineSearchSchema: new HotSchema({
        }),
    
        storeName:  'users',
    
        publicURL: '/users/:id',
        hotExpose: true,

      });
      stores.users = new Users();
    
      var UsersStrategies = declare( HotStore, {
    
        schema: new HotSchema({
          strategyId:  { type: 'blob', searchable: true, required: true, trim: 30 }  ,
          field1:      { type: 'blob', searchable: true, required: false, trim: 255 } ,
          field2:      { type: 'blob', searchable: true, required: false, trim: 255 } ,
          field3:      { type: 'blob', searchable: true, required: false, trim: 255 } ,
          field4:      { type: 'blob', searchable: true, required: false, trim: 255 } ,
        }),
    
        // Nothing is searchable in usersStrategies by default
        onlineSearchSchema: new HotSchema({
        }),

        storeName:  'usersStrategies',

        publicURL: '/users/:userId/strategies/:id',
        hotExpose: true,

        preserveCacheOnReset: true,

        handleGet: true,
        handleGetQuery: true,
        handleDelete: true,

        checkPermissions: function( request, method, cb ){

          switch( method ){
            case 'get':
            case 'getQuery':
              // Only their own strategies
              if( request.session.userId != request.params.userId ) return cb( null, false );
              return cb( null, true );
            break;

            case 'delete':
              // Only their own strategies
              if( request.session.userId != request.params.userId ) return cb( null, false );
    
              // Don't allow them to delete the last remaining strategy, or they will not be allowed back in
              stores.usersStrategies.dbLayer.selectByHash( { conditions: { userId: request.data.fullDoc.userId } }, { children: true }, function( err, queryDocs) {
                if( err ) return cb( err );

                if( queryDocs.length > 1 ){
                  cb( null, true );
                } else {
                  cb( null, false );
                }
              });
            break;

            default:
              // Let it pass by default
              return cb( null, true );
            break;

          }
        },
       
        // Make sure that, if the request is from the web, field3 and field4 are out of the equation as
        // they often include nice goodies like passwords etc.
        extrapolateDoc: function( request, method, doc, cb ){

          var doc = this._co( doc );

          // Local request: all good
          if( ! request.remote ) return cb( null, doc );
    
          // Remote request: delete field, and return
          delete doc[ 'field3' ];
          delete doc[ 'field4' ];

          cb( null, doc );
          
        },
    
      });
      stores.usersStrategies = new UsersStrategies();
      
    
      var AuthStrategies = declare( JsonRestStores, JsonRestStores.HTTPMixin, {
    
        schema: new SimpleSchema({
          id:        { type: 'blob', isRequired: true, trim: 30 }  ,
        }),

        handleGet: true,
        handleGetQuery: true,
    
        storeName:  'authStrategies',
   
        //logError: function( error ){ hotCoreServerLogger.log( error ); },
 
        publicURL: '/authstrategies/:id',
        hotExpose: true,

        implementFetchOne: function( request, cb ){
          var strategies = hotplate.config.get('hotCoreAuth.strategies');
          var doc;
    
          // No strategies defined in Hotplate, end of story
          if( typeof( strategies ) === 'undefined' ){
            return cb( null, null );     
          }
     
          // Check if the strategy is one of the ones defined in Hotplate
          if( typeof( strategies[ params.id ] ) !== 'undefined' ){
            doc = {}
            doc.id = params.id;
          } else {
            doc = null;
          }
    
          // Return whatever was found
          cb( null, doc );
        },
    
        implementQuery: function( request, cb ){
          var strategies = hotplate.config.get('hotCoreAuth.strategies');
          var doc;
          var docs = [];
          
          for( var strategyId in strategies ){
            docs.push( { id: strategyId } );
          }      
          cb( null, docs );
        },
    
    
      });
    
      stores.authStrategies = new AuthStrategies();
    
      // This is used so that an applicaton can know in advance if a user login is already taken
      var Logins = declare( JsonRestStores, JsonRestStores.HTTPMixin, {
    
        schema: new SimpleSchema({
          login     : { type: 'string', required: true, lowercase: true, trim: 30, searchable: true },
        }),
   
        storeName:  'logins',

        DbLayer: SimpleDbLayer,   

        handleGetQuery: true,

        publicURL: '/logins/:id',
        hotExpose: true,
    
        implementQuery: function( request, cb ){
          
          var self = this;
    
          stores.usersStrategies.dbLayer.selectByHash( { conditions: { strategyId: 'local', field1: request.options.conditions.login } }, { children: true }, function( err, res ){
            if( err ){
              cb( err, null );
            } else {
              if( res.length ){
                cb( null, [ { login: request.options.conditions.login } ] );
                // });
              } else {
                cb( null, [ ] );
              }
            }
          });      
    
        },   
    
      });
      stores.login = new Logins();
    
      done( null, stores );

    }
  });

}))

/**
Sets recover URL `/recover/:recoverToken` (for token recovery).  
Also goes through the list of `AuthStrategies`, loads the right
files in `auth/{strategy name}.js` (e.g. {{#crossLink "hotCoreAuth.facebook"}}{{/crossLink}}), and runs them.
This basically ensures that all strategies have the right URLs all set for them to work.

@event run
*/
hotplate.hotEvents.onCollect( 'setRoutes', hotplate.cachable( function( app, done ){

  hotCoreStoreRegistry.getAllStores( function( err, stores ){

    function makeResponder( req, res, next, strategyId, action ) {
  
      return function(err, user, profile ) {
  
        var responseType, strategies;
  
        var k = req.cookies[ strategyId + '-' + action ];
        if( typeof( k ) !== 'undefined' ){
          responseType = k;
        }
  
        // Fallback option
        if( ! responseType ) responseType = 'redirect';
  
        // Defaults to an empty profile object
        if( typeof( profile ) === 'undefined' ){
          profile = {};
        }
  
        // Error: just return/next that
        if( err ) { return next( err ); }
  
        // #1
  
        switch( responseType ){
  
          case 'content':
  
            // Work out the page's content by calling the user-set hotCoreAuth/responsePage function
            // Note: if hotCoreAuth/responsePage is not set, it will use a placeholder fallback string
            var content;
            var contentFunction = hotplate.config.get( 'hotCoreAuth.responsePage' );
            if( typeof( contentFunction ) === 'function' ){
              content = contentFunction( strategyId, action, user, profile );
            } else {
              content = "PLEASE SET hotCoreAuth/responsePage IN YOUR SERVER FILE TO CUSTOMIZE CONTENTS";
            }

            // Send the contents
            res.send( content );      
          break;
  
  
  
          case 'close':
  
            if( ! user && typeof( profile.message) !== 'undefined'  ){
              
              // FIXME: http://stackoverflow.com/questions/17141863/escaping-error-message-in-javascript
              res.send('<html><script>window.opener.alert("' + profile.message + '");window.close();</script></html>');      
            } else {
              res.send('<html><script>window.close();</script></html>');      
            }
          break;
  
          case 'ajax':
  
            if( user ){
              res.json( 200, { user: user, profile: profile } );
            } else {
              var error = 'Authentication error';
              if( typeof( profile.message) !== 'undefined' ) error =  profile.message;
              res.json( 403, { message: error } );
            }
  
          break;
  
  
          case 'redirect-opener':
  
            if( ! user && typeof( profile.message) !== 'undefined'  ){
  
              // FIXME: http://stackoverflow.com/questions/17141863/escaping-error-message-in-javascript
              res.send('<html><script>window.opener.alert("' + profile.message + '");window.close();</script></html>');      
              
            } else {
              var redirectURL = hotplate.config.get('hotCoreAuth.redirectURLs.success.' + action) || '/';
              res.send('<html><script>window.opener.location = "' + redirectURL + '";window.close();</script></html>');      
            }
          break;
  
  
          case 'redirect':
          default:
  
            if( user ){
              var redirectURL = hotplate.config.get('hotCoreAuth.redirectURLs.success.' + action) || '/';
              res.redirect( redirectURL );
            } else {
  
              // Add the error to the session messages
              if( typeof( profile.message) !== 'undefined'  ){
                req.session.messages = req.session.messages || []; 
                req.session.messages.push( { type: 'error', message: profile.message } );
              }
  
              var redirectURL = hotplate.config.get('hotCoreAuth.redirectURLs.fail.' + action) || '/';
              res.redirect( redirectURL );
            }
          break;
  
        }
  
      }
    }

    // ******************************
    // Function actually stats here
    // ******************************

    if( err ){
      done( err );
    } else {

      app.get('/recover/:recoverToken', function( req, res, next ){
    
        stores.users.dbLayer.selectByHash( { conditions: { recoverToken: req.params[ 'recoverToken' ] } }, { children: true }, function( err, result ){
          if( err ){
            done( err, null );
          } else {
            if( result.length == 0 ){
              // Error page
    
              // Artificially create a TokenInvalid error, and next( err ) it 
              var error = new Error();
              error.name = "TokenInvalidError";
              error.message = "Token not valid!";
              req.hotError = error;
              next( error );
    
            } else {
            
              var user = result[0];
    
              if( ! user.recoverTokenCreated ){
    
                // Artificially create a TokenDateInvalid error, and next( err ) it 
                var error = new Error();
                error.name = "TokenDateInvalidError";
                error.message = "Token date invalid!";
                req.hotError = error;
                next( error );
              } else {
    
                // Get the important variables 
                var tokenAgeInSeconds = Math.round( ( (new Date() ) - user.recoverTokenCreated ) / 1000 );
                var recoverURLexpiry = hotplate.config.get( 'hotCoreAuth.recoverURLexpiry' ); 
    
                var tokenIsGood = tokenAgeInSeconds < recoverURLexpiry;
    
                if( ! tokenIsGood ){
    
                  // Artificially create a TokenExpired error, and next( err ) it 
                  var error = new Error();
                  error.name = "TokenExpiredError";
                  error.message = "Token expired!";
                  req.hotError = error;
                  next( error );
    
                } else {
    
                  delete user.recoverToken;
                  delete user.recoverTokenCreated;

                  stores.users.dbLayer.updateById( user.id, { recoverToken: undefined, recoverTokenCreated: undefined }, function( err ){    
                    if( err ){
                      next( err );
                    } else {
    
                      // Log the user in using the token!
                      req.session.loggedIn = true;
                      req.session.userId = user.id;
    
                      // Redirect to the right URL
                      res.redirect( hotplate.config.get('hotCoreAuth.redirectURLs.success.recover') );
                    }
      
                  });
                }
                 
    
              }
              
            }
              
          }
        });
    
    
      }); 
    
    
      if( typeof( hotplate.config.get('hotCoreAuth.strategies' )) === 'object' ){
        Object.keys( hotplate.config.get('hotCoreAuth.strategies' )).forEach( function( strategyName ) {
        
          // Get the strategy's data
          var strategyConfig = hotplate.config.get('hotCoreAuth.strategies' )[strategyName];
    
          // Gets the right strategy maker and runs it
          var strategyMaker = require( './auth/' + strategyName );
          strategyMaker( app, strategyConfig, makeResponder, stores.authStrategies, stores.users, stores.usersStrategies, stores.logins );
        });
    
      }
    
      done( null );
    }
  });

}))


hotplate.hotEvents.onCollect( 'pageElements', 'hotCoreAuth', function( done ){
  var strategyIds = Object.keys( hotplate.config.get('hotCoreAuth.strategies') ) || [];
  
  done( null, {
    vars: [
            { name: 'strategyIds',  value: strategyIds },
            { name: 'successURLs',  value: hotplate.config.get('hotCoreAuth.redirectURLs.success') },
            { name: 'failURLs',     value: hotplate.config.get('hotCoreAuth.redirectURLs.fail') },
          ],
  });
});


hotplate.hotEvents.onCollect( 'pageElementsPerPage', 'hotCoreAuth', function( req, pageName, done ){

  var vars = [];

  // Add the user ID to the page as a variable
  if( req.session.userId ) {
    vars.push( { name: 'userId', value: req.session.userId } );
  }

  done( null, {
    vars: vars 
  });

});


