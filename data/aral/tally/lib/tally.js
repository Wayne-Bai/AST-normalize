// Generated by CoffeeScript 1.4.0

/*
Copyright 2013 Aral Balkan <aral@aralbalkan.com>
Copyright 2012 mocking@gmail.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Forked from Distal by mocking@gmail.com (https://code.google.com/p/distal/)
*/


(function() {
  var tally;

  tally = function(root, obj) {
    "use strict";

    var TAL, altAttr, attr, attr2, attributeWillChange, doc, formInputHasBody, format, getProp, html, i, innerText, isRunningOnServer, len, list, listStack, name, node, obj2, objList, pos, posStack, prefix, qattr, qdef, qdup, qif, qrepeat, qtext, querySelectorAll, resolve, shouldRenderStatic, textWillChange, tmpNode, value, wrapper, _results;
    wrapper = function() {};
    wrapper.prototype = obj;
    obj = new wrapper();
    resolve = tally.resolve;
    node = root;
    doc = root.ownerDocument;
    querySelectorAll = !!root.querySelectorAll;
    if (obj.__tally === void 0) {
      obj.__tally = {};
    }
    isRunningOnServer = obj.__tally.server;
    shouldRenderStatic = isRunningOnServer && obj.__tally.renderStatic;
    innerText = ("innerText" in root ? "innerText" : "textContent");
    altAttr = {
      className: 1,
      "class": 1,
      innerHTML: 1,
      style: 1,
      src: 1,
      href: 1,
      id: 1,
      value: 1,
      checked: 1,
      selected: 1,
      label: 1,
      htmlFor: 1,
      text: 1,
      title: 1,
      disabled: 1
    };
    formInputHasBody = {
      BUTTON: 1,
      LABEL: 1,
      LEGEND: 1,
      FIELDSET: 1,
      OPTION: 1
    };
    qdef = tally;
    attributeWillChange = qdef.attributeWillChange;
    textWillChange = qdef.textWillChange;
    qif = qdef.qif || "data-tally-if";
    qrepeat = qdef.qrepeat || "data-tally-repeat";
    qattr = qdef.qattr || "data-tally-attribute";
    qtext = qdef.qtext || "data-tally-text";
    qdup = qdef.qdup || "data-tally-dummy";
    format = qdef.format;
    qdef = qdef.qdef || "data-tally-alias";
    TAL = "*[" + [qdef, qif, qrepeat, qattr, qtext].join("],*[") + "]";
    html = void 0;
    getProp = function(s) {
      return this[s];
    };
    tmpNode = root.parentNode;
    while ((node = root.nextSibling) && (node.qdup || (node.nodeType === 1 && node.getAttribute(qdup)))) {
      tmpNode.removeChild(node);
    }
    listStack = void 0;
    posStack = [0];
    list = void 0;
    pos = 0;
    attr = void 0;
    attr2 = void 0;
    var undefined = {}._;

    if (querySelectorAll) {
      list = root.querySelectorAll("*[" + qdup + "]");
      while ((node = list[pos++])) {
        node.parentNode.removeChild(node);
      }
      pos = 0;
    }
    listStack = [(querySelectorAll ? root.querySelectorAll(TAL) : root.getElementsByTagName("*"))];
    list = [root];
    _results = [];
    while (true) {
      node = list[pos++];
      while (!node && (list = listStack.pop())) {
        pos = posStack.pop();
        node = list[pos++];
      }
      if (!node) {
        break;
      }
      attr = node.getAttribute(qdef);
      if (attr) {
        attr = attr.split(" ");
        html = resolve(obj, attr[1]);
        if (attr2 = attr[2]) {
          obj["#"] = parseInt(attr2) + 1;
          html = html[attr2];
        }
        obj[attr[0]] = html;
      }
      attr = node.getAttribute(qif);
      if (attr) {
        attr = attr.split(" ");
        if (attr[0].indexOf("not:") === 0) {
          attr = [attr[0].substr(4), "not", 0];
        }
        obj2 = resolve(obj, attr[0]);
        if (obj2 && obj2.join && obj2.length > -1) {
          obj2 = obj2.length;
        }
        if (attr.length > 2) {
          if (attr[3]) {
            attr[2] = attr.slice(2).join(" ");
          }
          if (typeof obj2 === "number") {
            attr[2] *= 1;
          }
          switch (attr[1]) {
            case "not":
              attr = !obj2;
              break;
            case "is":
              attr = obj2 === attr[2];
              break;
            case "isNot":
              attr = obj2 !== attr[2];
              break;
            case "isGreaterThan":
              attr = obj2 > attr[2];
              break;
            case "isLessThan":
              attr = obj2 < attr[2];
              break;
            case "contains":
              attr = obj2 && obj2.indexOf(attr[2]) >= 0;
              break;
            case "doesNotContain":
              attr = obj2 && obj2.indexOf(attr[2]) < 0;
              break;
            default:
              throw new Error('Unknown conditional operator (‘' + attr[1] + '’) in ' + node.outerHTML + '. Valid operators are: not:, is, isNot, isGreatherThan, isLessThan, contains, and doesNotContain.');
          }
        } else {
          attr = obj2;
        }
        if (attr) {
          if (!shouldRenderStatic) {
            if (node.style.removeProperty) {
              node.style.removeProperty('display');
            } else {
              node.style.removeAttribute('display');
            }
          }
        } else {
          if (querySelectorAll) {
            pos += node.querySelectorAll(TAL).length;
          } else {
            pos += node.getElementsByTagName("*").length;
          }
          if (shouldRenderStatic) {
            node.parentNode.removeChild(node);
          } else {
            node.style.display = "none";
          }
          continue;
        }
      }
      attr = node.getAttribute(qrepeat);
      if (attr) {
        attr2 = attr.split(" ");
        if (!querySelectorAll) {
          html = node.parentNode;
          while ((tmpNode = node.nextSibling) && (tmpNode.qdup || (tmpNode.nodeType === 1 && tmpNode.getAttribute(qdup)))) {
            html.removeChild(tmpNode);
          }
        }
        if (!attr2[1]) {
          throw new Error('missing second attribute (collection name) in data-tally-repeat: ' + node.outerHTML + '. The correct syntax is data-tally-repeat="value collection". e.g., to iterate over an array called people: data-tally-repeat="person people". And then, from within the loop, you can access properties of the person object (e.g., person.name, person.age, etc.)');
        }
        objList = resolve(obj, attr2[1]);
        if (objList && objList.length) {
          if (!shouldRenderStatic) {
            if (node.style.removeProperty) {
              node.style.removeProperty('display');
            } else {
              node.style.removeAttribute('display');
            }
          }
          obj[attr2[0]] = objList[0];
          obj["#"] = 1;
        } else {
          if (shouldRenderStatic) {
            if (querySelectorAll) {
              pos += node.querySelectorAll(TAL).length;
            } else {
              pos += node.getElementsByTagName("*").length;
            }
            node.parentNode.removeChild(node);
          } else {
            node.style.display = "none";
            if (querySelectorAll) {
              pos += node.querySelectorAll(TAL).length;
            } else {
              pos += node.getElementsByTagName("*").length;
            }
          }
          continue;
        }
        if (objList.length > 1) {
          html = new Array(objList.length - 1);
          len = html.length;
          i = len;
          while (i > 0) {
            html[len - i] = i;
            i--;
          }
          tmpNode = node.cloneNode(true);
          if ("form" in tmpNode) {
            tmpNode.checked = false;
          }
          tmpNode.setAttribute(qdef, attr);
          tmpNode.removeAttribute(qrepeat);
          tmpNode.setAttribute(qdup, "1");
          tmpNode = tmpNode.outerHTML || doc.createElement("div").appendChild(tmpNode).parentNode.innerHTML;
          prefix = tmpNode.indexOf(" " + qdef + "=\"" + attr + "\"");
          if (prefix === -1) {
            prefix = tmpNode.indexOf(" " + qdef + "='" + attr + "'");
          }
          prefix = prefix + qdef.length + 3 + attr.length;
          html = tmpNode.substr(0, prefix) + " " + html.join(tmpNode.substr(prefix) + tmpNode.substr(0, prefix) + " ") + tmpNode.substr(prefix);
          tmpNode = doc.createElement("div");
          if ("cells" in node && !("tBodies" in node)) {
            tmpNode.innerHTML = "<table>" + html + "</table>";
            tmpNode = tmpNode.firstChild.tBodies[0].childNodes;
          } else if ("cellIndex" in node) {
            tmpNode.innerHTML = "<table><tr>" + html + "</tr></table>";
            tmpNode = tmpNode.firstChild.tBodies[0].firstChild.childNodes;
          } else if ("selected" in node && "text" in node) {
            tmpNode.innerHTML = "<select>" + html + "</select>";
            tmpNode = tmpNode.firstChild.childNodes;
          } else {
            tmpNode.innerHTML = html;
            tmpNode = tmpNode.childNodes;
          }
          prefix = node.parentNode;
          attr2 = node.nextSibling;
          if (querySelectorAll || node === root) {
            listStack.push(list);
            posStack.push(pos);
            list = {
              getAttribute: getProp
            };
            list[qdef] = attr + " 0";
            listStack.push([list]);
            posStack.push(0);
            list = [];
            i = tmpNode.length - 1;
            while (i >= 0) {
              html = tmpNode[i];
              listStack.push((querySelectorAll ? html.querySelectorAll(TAL) : html.getElementsByTagName("*")));
              posStack.push(0);
              listStack.push([html]);
              posStack.push(0);
              html.qdup = 1;
              prefix.insertBefore(html, attr2);
              i--;
            }
          } else {
            i = tmpNode.length - 1;
            while (i >= 0) {
              html = tmpNode[i];
              html.qdup = 1;
              prefix.insertBefore(html, attr2);
              i--;
            }
          }
          prefix.selectedIndex = -1;
        }
      }
      attr = node.getAttribute(qattr);
      if (attr) {
        attr = attr.trim();
        if (attr === '') {
          throw new Error('empty data-tally-attribute definition on element: ' + node.outerHTML);
        }
        name = void 0;
        value = void 0;
        html = attr.split("; ");
        i = html.length - 1;
        while (i >= 0) {
          attr = html[i].split(" ");
          name = attr[0];
          if (!name) {
            throw new Error('missing attribute name for attribute ' + i + ': ' + node.outerHTML);
          }
          if (!attr[1]) {
            throw new Error('missing attribute value for attribute ' + i + ' (‘' + name + '’): ' + node.outerHTML);
          }
          value = resolve(obj, attr[1]);
          if (value === undefined) {
            value = "";
          }
          if (attributeWillChange) {
            attributeWillChange(node, name, value);
          }
          if (attr = attr[2] && format[attr[2]]) {
            value = attr(value);
          }
          if (altAttr[name]) {
            switch (name) {
              case "innerHTML":
                throw new Error('setting the innerHTML attribute via data-tally-atttribute is not supported. Please use data-tally-text to set the text in ' + node.outerHTML);
                break;
              case "disabled":
              case "checked":
              case "selected":
                node[name] = !!value;
                break;
              case "style":
                node.style.cssText = value;
                break;
              case "text":
                node[(querySelectorAll ? name : innerText)] = value;
                break;
              case "class":
                node["className"] = value;
                break;
              default:
                node[name] = value;
            }
          } else {
            node.setAttribute(name, value);
          }
          i--;
        }
      } else {
        if (node.hasAttribute) {
          if (node.hasAttribute(qattr)) {
            throw new Error('empty data-tally-attribute definition on element: ' + node.outerHTML);
          }
        }
      }
      attr = node.getAttribute(qtext);
      if (attr) {
        attr = attr.split(" ");
        html = attr[0] === "html";
        attr2 = resolve(obj, attr[(html ? 1 : 0)]);
        if (attr2 === undefined) {
          attr2 = "";
        }
        if (textWillChange) {
          textWillChange(node, attr2);
        }
        if ((attr = attr[(html ? 2 : 1)]) && (attr = format[attr])) {
          attr2 = attr(attr2);
        }
        if (html) {
          _results.push(node.innerHTML = attr2);
        } else {
          _results.push(node[("form" in node && !formInputHasBody[node.tagName] ? "value" : innerText)] = attr2);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  tally.resolve = function(obj, seq, x, lastObj) {
    if (x = obj[seq]) {
      return (typeof x === "function" ? x.call(obj, seq) : x);
    }
    seq = seq.split(".");
    x = 0;
    while (seq[x] && (lastObj = obj) && (obj = obj[seq[x++]])) {}
    if (typeof obj === "function") {
      return obj.call(lastObj, seq.join("."));
    } else {
      return obj;
    }
  };

  tally.format = {
    ",.": function(v, i) {
      i = v * 1;
      if (isNaN(i)) {
        return v;
      } else {
        return (i % 1 ? i.toFixed(2) : parseInt(i, 10) + "").replace(/(^\d{1,3}|\d{3})(?=(?:\d{3})+(?:$|\.))/g, "$1,");
      }
    }
  };

  if (typeof define === "function" && define.amd) {
    define("tally", function() {
      return tally;
    });
  } else {
    window.tally = tally;
  }

}).call(this);
