var IE9Fix = function() {
  // Generated by CoffeeScript 1.6.3 from https://gist.github.com/MrOrz/6405400
  // The above was linked from https://github.com/angular/angular.js/pull/1047
  // Note: only GET and POST requests are supported

  var OriginalXMLHttpRequest, isXDomain, _base,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  if (!(window.XDomainRequest && !(__indexOf.call(window.XMLHttpRequest, "withCredentials") >= 0))) {
    return;
  }


  OriginalXMLHttpRequest = window.XMLHttpRequest;

  if ((_base = window.location).origin == null) {
    _base.origin = window.location.protocol + '//' + window.location.host;
  }

  isXDomain = function(requestUrl) {
    // gjn: replaced the whole function.
    // original is still commented below
    var getHostName = function(url) {
      var l = window.document.createElement('a');
      l.href = url;
      return l.hostname
        .replace('http://', '')
        .replace('https://', '');
    };

    var host = window.location.origin
        .replace('http://', '')
        .replace('https://', '');

    var requestUrlHost = getHostName(requestUrl);

    //if host are identical, then not XDomain
    if (requestUrlHost === host) {
      return false;
    }
    //check for relative url
    if (!/^https?:\/\//.test(requestUrl)) {
      return false;
    }
    return true;
    /*
    if (requestUrl[0] === '/') {
      if (requestUrl.length === 1) {
        return false;
      }
      if (requestUrl[1] === '/') {
        return true;
      } else {
        return false;
      }
    }
    return requestUrl.slice(0, window.location.origin.length) !== window.location.origin;
    */
  };

  window.XMLHttpRequest = (function() {
    function XMLHttpRequest() {}

    XMLHttpRequest.prototype.open = function() {
      var func, method, others, url, _fn, _fn1, _i, _j, _len, _len1, _ref, _ref1,
        _this = this;
      method = arguments[0], url = arguments[1], others = 3 <= arguments.length ? __slice.call(arguments, 2) : [];

      if (!isXDomain(url)) {
        this.implementation = new OriginalXMLHttpRequest;
        this.implementation.onload = function() {
          var prop, _i, _len, _ref;
          if (_this.implementation.readyState === 4) {
            _ref = ['readyState', 'status', 'responseText'];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              prop = _ref[_i];
              _this[prop] = _this.implementation[prop];
            }
          }
          if (_this.onload) {
            return _this.onload();
          }
        };
        _ref = ['abort', 'getAllResponseHeaders', 'getResponseHeader', 'send', 'setRequestHeader'];
        _fn = function(func) {
          return _this[func] = function() {
            var _ref1;
            return (_ref1 = this.implementation)[func].apply(_ref1, arguments);
          };
        };
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          func = _ref[_i];
          _fn(func);
        }
      } else {
        this.implementation = new XDomainRequest;
        this.implementation.onload = function() {
          _this.responseText = _this.implementation.responseText;
          _this.readyState = 4;
          _this.status = 200;
          if (_this.onload) {
            return _this.onload();
          }
        };
        // gjn fix (needs to be done)
        this.implementation.onprogress = function () {};
        // end of fix 
        this.abort = function() {
          var _ref1;
          return (_ref1 = this.implementation).abort.apply(_ref1, arguments);
        };
        this.send = function() {
          var _ref1;
          return (_ref1 = _this.implementation).send.apply(_ref1, arguments);
        };
        _ref1 = ['getResponseHeader', 'getAllResponseHeaders', 'setRequestHeader', 'onprogress', 'onerror', 'ontimeout'];
        _fn1 = function(func) {
          return _this[func] = function() {};
        };
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          func = _ref1[_j];
          _fn1(func);
        }
      }
      return this.implementation.open(method, url);
    };

    return XMLHttpRequest;

  })();

};

