// Copyright (c) 2014 Tom Steele, Dan Kottmann, FishNet Security
// See the file license.txt for copying permission

Template.vulnerabilityGist.vulnerability = function() {
  var vulnerability = Vulnerabilities.findOne({"project_id": Session.get('projectId'), "_id": Session.get('vulnerabilityId')});
  if (!vulnerability) {
    return false;
  }
  return vulnerability;
};

Template.vulnerabilityGist.events({
  'click .flag-enabled': function() {
    return Meteor.call('disableVulnerabilityFlag', Session.get('projectId'), this._id);
  },

  'click .flag-disabled': function() {
    return Meteor.call('enableVulnerabilityFlag', Session.get('projectId'), this._id);
  },

  'click .confirmed-enabled': function() {
    return Meteor.call('disableVulnerabilityConfirmed', Session.get('projectId'), this._id);
  },

  'click .confirmed-disabled': function() {
    return Meteor.call('enableVulnerabilityConfirmed', Session.get('projectId'), this._id);
  },

  'click .vulnerability-status': function() {
    var status = STATUS_MAP[STATUS_MAP.indexOf(this.status) + 1];
    if (STATUS_MAP.indexOf(this.status) + 1 > 4) {
      status = STATUS_MAP[0];
    }
    return Meteor.call('setVulnerabilityStatus', Session.get('projectId'), this._id, status);
  },

  'click #next-vulnerability': function() {
    var id = Session.get('projectId');
    var vulnerabilities = Vulnerabilities.find({"project_id": id}, {sort: {"cvss": -1, "title": 1}}).fetch();
    var i = _.indexOf(_.pluck(vulnerabilities, '_id'), Session.get('vulnerabilityId')) + 1;
    if (i >= vulnerabilities.length) {
      return Router.go('/project/' + id + '/vulnerabilities/' + Session.get('vulnerabilityId') + '/next');
    }
    return Router.go('/project/' + id + '/vulnerabilities/' + vulnerabilities[i]._id);
  },

  'click #previous-vulnerability': function() {
    var id = Session.get('projectId');
    var vulnerabilities = Vulnerabilities.find({"project_id": id}, {sort: {"cvss": -1, "title": 1}}).fetch();
    var i = _.indexOf(_.pluck(vulnerabilities, '_id'), Session.get('vulnerabilityId')) - 1;
    if (i < 0) {
      return Router.go('/project/' + id + '/vulnerabilities/' + Session.get('vulnerabilityId') + '/prev');
    }
    return Router.go('/project/' + id + '/vulnerabilities/' + vulnerabilities[i]._id);
  },

  'click #remove-vulnerability': function() {
    var id = Session.get('projectId');
    var vulnerabilityId = Session.get('vulnerabilityId');
    Meteor.call('removeVulnerability', id, vulnerabilityId, function(err) {
      if (!err) {
        return Router.go('/project/' + id + '/vulnerabilities');
      }
      return Alerts.insert({"class": "alert-error", "strong": "Error", "message": err.reason});
    });
  },

  'click #edit-vulnerability': function(event, tpl) {
    var projectId = Session.get('projectId');
    var vulnerabilityId = Session.get('vulnerabilityId');
    var title = tpl.find('[name=edit-title]').value;
    var cvss = tpl.find('[name=edit-cvss]').value;
    tpl.find('[name=edit-title]').value = '';
    tpl.find('[name=edit-cvss]').value = '';
    if (title) {
      Meteor.call('setVulnerabilityTitle', projectId, vulnerabilityId, title, function(err) {
        if (err) {
          Alerts.insert({"class": "alert-error", "strong": "Error", "message": err.reason});
        }
      });
    }
    if (cvss) {
      Meteor.call('setVulnerabilityCvss', projectId, vulnerabilityId, cvss, function(err) {
        if (err) {
          Alerts.insert({"class": "alert-error", "strong": "Error", "message": err.reason});
        }
      });
    }
  }

});
