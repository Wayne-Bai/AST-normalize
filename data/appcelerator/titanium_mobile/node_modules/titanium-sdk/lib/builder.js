/**
 * @overview
 * The base class for platform specific build commands. This ensures some
 * commonality between build commands so that hooks can consistently
 * access build properties.
 *
 * @copyright
 * Copyright (c) 2009-2014 by Appcelerator, Inc. All Rights Reserved.
 *
 * @license
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

const
	appc = require('node-appc'),
	crypto = require('crypto'),
	fs = require('fs'),
	path = require('path'),
	ti = require('titanium-sdk'),
	__ = appc.i18n(__dirname).__;

/**
 * The base class for platform specific build commands. This ensures some
 * commonality between build commands so that hooks can consistently
 * access build properties.
 *
 * General usage is to extend the Builder class and override the config(),
 * validate(), and run() methods:
 *
 * var Builder = require('titanium-sdk/lib/builder');
 * var util = require('util');
 *
 * function SomePlatformBuilder() {
 *     Builder.apply(this, arguments);
 * }
 *
 * util.inherits(SomePlatformBuilder, Builder);
 *
 * SomePlatformBuilder.prototype.config = function config(logger, config, cli) {
 *     Builder.prototype.config.apply(this, arguments);
 *     // TODO
 * };
 *
 * SomePlatformBuilder.prototype.validate = function validate(logger, config, cli) {
 *     // TODO
 * };
 *
 * SomePlatformBuilder.prototype.run = function run(logger, config, cli, finished) {
 *     Builder.prototype.run.apply(this, arguments);
 *     // TODO
 *     finished();
 * };
 *
 * @module lib/builder
 */

module.exports = Builder;

/**
 * Constructs the build state. This needs to be explicitly called from the
 * derived builder's constructor.
 *
 * @class
 * @classdesc Base class for all build states.
 * @constructor
 *
 * @param {Module} The "module" variable from the build command file
 */
function Builder(buildModule) {
	this.titaniumSdkPath = (function scan(dir) {
		var file = path.join(dir, 'manifest.json');
		if (fs.existsSync(file)) {
			return dir;
		}
		dir = path.dirname(dir);
		return dir != '/' && scan(dir);
	}(__dirname));

	this.titaniumSdkName = path.basename(this.titaniumSdkPath);

	this.titaniumSdkVersion = ti.manifest.version;

	this.platformPath = (function scan(dir) {
		var file = path.join(dir, 'package.json');
		if (fs.existsSync(file)) {
			return dir;
		}
		dir = path.dirname(dir);
		return dir != '/' && scan(dir);
	}(path.dirname(buildModule.filename)));

	this.platformName = path.basename(this.platformPath);

	this.globalModulesPath = path.join(this.titaniumSdkPath, '..', '..', 'modules');

	this.packageJson = require(path.join(this.platformPath, 'package.json'));

	this.conf = {};
}

/**
 * Defines common variables prior to running the build's config(). This super
 * function should be called prior to the platform-specific build command's config().
 *
 * @param {Object} logger - The logger instance
 * @param {Object} config - The CLI config
 * @param {Object} cli - The CLI instance
 */
Builder.prototype.config = function config(logger, config, cli) {
	this.logger = logger;
	this.config = config;
	this.cli = cli;
};

/**
 * Validation stub function. Meant to be overwritten.
 *
 * @param {Object} logger - The logger instance
 * @param {Object} config - The CLI config
 * @param {Object} cli - The CLI instance
 */
Builder.prototype.validate = function validate(logger, config, cli) {
	this.tiapp = cli.tiapp;
	this.timodule = cli.timodule;
	this.projectDir = cli.argv['project-dir'];
	this.buildDir = path.join(this.projectDir, 'build', this.platformName);
};

/**
 * Defines common variables prior to running the build. This super function
 * should be called prior to the platform-specific build command's run().
 *
 * @param {Object} logger - The logger instance
 * @param {Object} config - The CLI config
 * @param {Object} cli - The CLI instance
 * @param {Function} finished - A function to call after the function finishes
 */
Builder.prototype.run = function run(logger, config, cli, finished) {
};

/**
 * Validates that all required Titanium Modules defined in the tiapp.xml are
 * installed.
 *
 * This function is intended to be called asynchronously from the validate()
 * implementation. In other words, validate() should return a function that
 * calls this function.
 *
 * Note: This function will forcefully exit the application on error!
 *
 * @example
 *     SomePlatformBuilder.prototype.validate = function validate(logger, config, cli) {
 *         Builder.prototype.validate.apply(this, arguments);
 *
 *         // TODO: synchronous platform specific validation code goes here
 *
 *         return function (callback) {
 *             // TODO: asynchronous platform specific validation code goes here
 *
 *             this.validateTiModules(callback);
 *         }.bind(this);
 *     };
 *
 * @param {String|Array} platformName - One or more platform names to use when finding Titanium modules
 * @param {String} deployType - The deployment type (development, test, production)
 * @param {Function} callback(err) - A function to call after the function finishes
 */
Builder.prototype.validateTiModules = function validateTiModules(platformName, deployType, callback) {
	var moduleSearchPaths = [ this.projectDir ],
		customSDKPaths = this.config.get('paths.sdks'),
		customModulePaths = this.config.get('paths.modules');

	function addSearchPath(p) {
		p = appc.fs.resolvePath(p);
		if (fs.existsSync(p) && moduleSearchPaths.indexOf(p) === -1) {
			moduleSearchPaths.push(p);
		}
	}

	this.cli.env.os.sdkPaths.forEach(addSearchPath);
	Array.isArray(customSDKPaths) && customSDKPaths.forEach(addSearchPath);
	Array.isArray(customModulePaths) && customModulePaths.forEach(addSearchPath);

	appc.timodule.find(this.cli.tiapp.modules, platformName, deployType, this.titaniumSdkVersion, moduleSearchPaths, this.logger, function (modules) {
		if (modules.missing.length) {
			this.logger.error(__('Could not find all required Titanium Modules:'))
			modules.missing.forEach(function (m) {
				this.logger.error('   id: ' + m.id + '\t version: ' + (m.version || 'latest') + '\t platform: ' + m.platform + '\t deploy-type: ' + m.deployType);
			}, this);
			this.logger.log();
			process.exit(1);
		}

		if (modules.incompatible.length) {
			this.logger.error(__('Found incompatible Titanium Modules:'));
			modules.incompatible.forEach(function (m) {
				this.logger.error('   id: ' + m.id + '\t version: ' + (m.version || 'latest') + '\t platform: ' + m.platform + '\t min sdk: ' + (m.manifest && m.manifest.minsdk || '?'));
			}, this);
			this.logger.log();
			process.exit(1);
		}

		if (modules.conflict.length) {
			this.logger.error(__('Found conflicting Titanium modules:'));
			modules.conflict.forEach(function (m) {
				this.logger.error('   ' + __('Titanium module "%s" requested for both Android and CommonJS platforms, but only one may be used at a time.', m.id));
			}, this);
			this.logger.log();
			process.exit(1);
		}

		callback(null, modules);
	}.bind(this)); // end timodule.find()
};

/**
 * Returns the hexadecimal md5 hash of a string.
 *
 * @param {String} str - The string to hash
 *
 * @returns {String}
 */
Builder.prototype.hash = function hash(str) {
	return crypto.createHash('md5').update(str || '').digest('hex');
};
