'use strict';

var util = require('util'),
	merge = require('merge'),
	EventEmitter = require('events').EventEmitter,
	Err = require('./error.js'),
	constants = require('./constants'),
	DEFAULTS = constants.OPTIONS,
	EVENTS = constants.SP,
	debug = constants.debug('GCM'),
	Dequeue = require('dequeue'),
	https = require('https'),
	_ = require('underscore');

var GCM = function(credentials){
	if (false === (this instanceof GCM)) {
        return new GCM(credentials);
    }

	this.options = merge({}, DEFAULTS, credentials);

	// Buffer for ready to send notifications [uint32 notification id, device, data]
	this.notifications = new Dequeue();

	this.currentId = 0;

	EventEmitter.call(this);
};
util.inherits(GCM, EventEmitter);

// Helper methods to remind notification object indexes
var noteDevice = function(note){ return note ? note[0] : undefined; };
var noteData = function(note){ return note ? note[1] : undefined; };
var noteMessageId = function(note){ return note ? note[2] : undefined; };

/**
 * @private
 */
GCM.prototype.serviceImmediate = function() {
	if (!this.servicingImmediate) {
		this.servicingImmediate = true;
		setImmediate(function(){
			this.servicingImmediate = false;
			this.service();
		}.bind(this));
	}
};

/**
 * @private
 */
GCM.prototype.service = function() {
	// Socket is ready to go, send notification
	if (this.notifications.length && !this.requesting) {
		var notification = this.notifications.shift(), merged = 1;
		while (this.notifications.length > 0 && merged < this.options.gcmTransmitAtOnce) {
			var next = this.notifications.shift();
			console.log('next is %j, %j, %j', next[0], next[1], next[2]);
			if (noteMessageId(notification) === noteMessageId(next) && _.isEqual(noteData(notification), noteData(next))) {
				console.log('merging');
				for (var i = 0; i < noteDevice(next).length; i++) {
					merged++;
					noteDevice(notification).push(noteDevice(next)[i]);
				}
			} else {
				this.notifications.unshift(next);
				break;
			}
		}
		debug('merged %d, %d left to send', merged, this.notifications.length);
		this.transmit(notification);
	} else if (!this.notifications.length && typeof this.closed === 'function') {
		this.closed();
	}
};

/**
 * Handle a particular error type: either just emit it, or remove a message from queue completely
 * @private
 */
GCM.prototype.handlerr = function (note, code, name, messageId, deviceTokens) {
	debug('Handling error code %d, name %j for note %j, message ID %j, device token %j', code, name, note, messageId, deviceTokens);

	var err = new Err(code, name, messageId, deviceTokens), que = new Dequeue(), notification, id = noteMessageId(note);

	this.requesting = false;

	if (code === Err.TOKEN) {
		this.emit(EVENTS.ERROR, err);
		this.serviceImmediate();
	} else if (code & Err.IS_RECOVERABLE) {
		this.notifications.unshift(note);
		this.emit(EVENTS.ERROR, err);
		this.serviceImmediate();
	} else if (code & Err.IS_NON_RECOVERABLE) {
		this.emit(EVENTS.ERROR, err);
		while (this.notifications.length) {
			notification = this.notifications.shift();
			if (noteMessageId(notification) !== id) {
				que.push(notification);
			}
		}
		this.notifications = que;
		this.emit(EVENTS.ERROR, err);
		this.serviceImmediate();
	}
};

/**
 * @private
 */
GCM.prototype.onRequestDone = function(note, code, data) {
    this.emit(EVENTS.MESSAGE, noteMessageId(note), noteDevice(note).length);
	if (code >= 500) {
		this.handlerr(note, Err.CONNECTION, 'GCM Unavailable');
    } else if (code === 401) {
		this.handlerr(note, Err.CREDENTIALS, 'GCM Unauthorized', noteMessageId(note));
    } else if (code === 400) {
		this.handlerr(note, Err.MESSAGE, 'GCM Bad message', noteMessageId(note));
    } else if (code !== 200) {
		this.handlerr(note, Err.CONNECTION, 'GCM Bad response code ' + code);
    } else {
		this.requesting = false;
    	try {
            var obj = JSON.parse(data);
            if (obj.failure === 0 && obj.canonical_ids === 0) {
                // this.emit(EVENTS.MESSAGE, noteMessageId(note), noteDevice(note).length);
            } else if (obj.results) {
            	var resend = [], devicesWithInvalidTokens = [], devicesWithBadCredentials = [], validDevices = [], i, device, oldDevices = noteDevice(note);

                for (i in obj.results) {
                    var result = obj.results[i];
                    device = oldDevices[i];

                    if (result.message_id) {
                    	if (result.registration_id) {
	                    	devicesWithInvalidTokens.push({bad: device, good: result.registration_id});
                    	}
                    	validDevices.push(device);
                    } else if (result.error === 'MessageTooBig') {
	                	this.handlerr(note, Err.MESSAGE, 'GCM Message Too Big', noteMessageId(note), devicesWithBadCredentials);
	                	return;
                    } else if (result.error === 'InvalidDataKey') {
	                	this.handlerr(note, Err.MESSAGE, 'Invalid Data Key: ' + data, noteMessageId(note));
	                	return;
                    } else if (result.error === 'InvalidTtl') {
	                	this.handlerr(note, Err.MESSAGE, 'Invalid Time To Live: ' + data, noteMessageId(note));
	                	return;
                    } else if (result.error === 'InvalidTtl') {
	                	this.handlerr(note, Err.MESSAGE, 'Invalid Time To Live: ' + data, noteMessageId(note));
	                	return;
                    } else if (result.error === 'InvalidPackageName') {
	                	this.handlerr(note, Err.MESSAGE, 'Invalid Package Name: ' + data, noteMessageId(note));
	                	return;
                    } else if (result.error === 'Unavailable' || result.error === 'InternalServerError') {
                    	resend.push(device);
                    } else if (result.error === 'MismatchSenderId') {
                    	devicesWithBadCredentials.push(device);
                    } else if (result.error === 'NotRegistered' || result.error === 'InvalidRegistration') {
                    	devicesWithInvalidTokens.push({bad: device});
                    } else if (result.error) {
                    	devicesWithInvalidTokens.push({bad: device});
                    }
                }


                if (devicesWithInvalidTokens.length) {
					this.handlerr(note, Err.TOKEN, 'GCM Invalid tokens', noteMessageId(note), devicesWithInvalidTokens);
                }

                if (validDevices.length) {
	                // this.emit(EVENTS.MESSAGE, noteMessageId(note), validDevices.length);
                }

                if (devicesWithBadCredentials.length) {
                	this.handlerr(note, Err.MESSAGE, 'GCM Mismatched Sender', noteMessageId(note), devicesWithBadCredentials);
                } else if (resend.length) {
                	note[0] = resend;
					this.handlerr(note, Err.CONNECTION, 'GCM Unavailable');
                }
            }
			this.serviceImmediate();
    	} catch (e) {
			this.handlerr(note, Err.CONNECTION, e, noteMessageId(note));
    	}
	}
};

/**
 * @private
 */
GCM.prototype.transmit = function(note) {
	var devices = noteDevice(note), content = noteData(note);
    debug('Going to transmit %j to %j', content, devices);

    content.registration_ids = devices;
	content = JSON.stringify(content);
    debug('Transmitting %j', content);

	var options = {
		hostname: 'android.googleapis.com',
		port: 443,
		path: '/gcm/send',
		method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Content-length': Buffer.byteLength(content, 'utf8'),
            'Authorization': 'key=' + this.options.key,
        },
	};

	if (!this.agent) {
		this.agent = new https.Agent(options);
		this.agent.maxSockets = 1;
	}

	options.agent = this.agent;

	this.requesting = true;
	var req = https.request(options, function(res) {
		if (res.statusCode !== 200) {
        	this.onRequestDone(note, res.statusCode, '');
        	res.on('data', function(d) {
        		process.stderr.write(d);
    	  	});
		} else {
			var data = '';
			res.on('data', function(d) {
	            data += d;
			});
	        res.on('end', function(){
	        	this.onRequestDone(note, res.statusCode, data);
	        }.bind(this));
	        res.on('close', function(){
	        	this.onRequestDone(note, res.statusCode, data);
	        }.bind(this));
		}
	}.bind(this));

	req.on('socket', function(socket){
		this.socket = socket;
	}.bind(this));

	req.on('error', function(err){
		this.handlerr(note, Err.CONNECTION, err);
	}.bind(this));

	req.end(content);
};

/**
 * Stop accepting new messages and close socket whenever all are sent
 */
GCM.prototype.close = function (clb) {
	this.closed = clb || true;
	if (this.socket) {
		this.socket.emit('agentRemove');
	}
	if (!this.notifications.length && typeof this.closed === 'function') {
		this.closed();
	}
};

/**
 * Remove all notifications for a particular message
 */
GCM.prototype.abort = function (message) {
	var que = new Dequeue(), notification;
	while (this.notifications.length) {
		notification = this.notifications.shift();
		if (noteMessageId(notification) !== message.id) {
			que.push(notification);
		}
	}
	debug('Left %d out of %d notifications in queue due to message abort', this.notifications.length, this.notifications.length + que.length);
	this.notifications = que;
	this.serviceImmediate();
};

/**
 * Whether this connection is not full of unsent messages
 */
GCM.prototype.free = function () {
	return this.notifications.length < this.options.queue;
};

/**
 * Queue a message for delivery to recipients
 * @param {String} content Compiled according to Apple guidelines message to send.
 * @param {String} encoding Encoding of message. Defaults to 'utf8', @see message.js.
 * @param {Date} expiry Expiry time of message. Defaults to 1 week from message creation, @see message.js.
 * @param {Buffer} device Buffer with device token.
 */
GCM.prototype.send = function (messageId, content, encoding, expiry, device, locale) {
	if (!this.free() || this.closed) {
		return -1;
	}

	if (typeof content === 'string') {
		// do nothing
	} else if (locale) {
		if (content[locale]) {
			content = content[locale];
		} else if (content['default']) {
			content = content['default'];
		} else {
			this.handlerr([device, content, messageId], Err.MESSAGE, 'No default locale in localized message', messageId);
			return;
		}
	} else {
		if (content['default']) {
			content = content['default'];
		} else {
			this.handlerr([device, content, messageId], Err.MESSAGE, 'No locale provided for device when sending localized message', messageId);
			return;
		}
	}

    device = util.isArray(device) ? device : [device];

    // debug('Adding locale %j: %j, %j, %j to queue', locale, device, content, messageId);
	this.notifications.push([device, content, messageId]);

	this.serviceImmediate();

	return 0;
};


var FixedSizeDequeue = function(size){
	this.size = size;
	Dequeue.call(this);
};
FixedSizeDequeue.prototype.push = function(d) {
	if (this.length >= this.size) {
		Dequeue.super_.prototype.shift.apply(this);
	}
	Dequeue.super_.prototype.push.apply(this, [d]);
};
util.inherits(FixedSizeDequeue, Dequeue);

module.exports = GCM;
