// Generated by CoffeeScript 1.7.1
(function() {
  define(function(require, exports, module) {
    var Anchor, EditSession, Range, Tab, TabList, UndoManager;
    EditSession = require('ace/edit_session').EditSession;
    Anchor = require('ace/anchor').Anchor;
    Range = require('ace/range').Range;
    UndoManager = require('ace/undomanager').UndoManager;
    Tab = Backbone.Model.extend({
      defaults: function() {
        return {
          offset: 10000,
          saved: true
        };
      },
      initialize: function() {
        var file, project;
        _.bindAll(this, 'selectionchange', 'filedidchange', 'showCompletions', 'onManagerUpdate', 'onLoaded', 'tryCompletion');
        this.on('destroy', this.onRemove, this);
        this.session = new EditSession('');
        this.filedidchange();
        project = app.console.project;
        this.session.setUseSoftTabs(project.get('softTabs'));
        this.session.setTabSize(project.get('tabSize'));
        this.session.setUseWrapMode(true);
        this.session.doc.on('change', (function(_this) {
          return function() {
            return _this.set({
              saved: false
            });
          };
        })(this));
        this.session.on('stats', (function(_this) {
          return function(stats) {
            var _ref;
            return (_ref = app.stats) != null ? _ref.addStats(_this.get('url'), stats) : void 0;
          };
        })(this));
        this.tryCompletionDebounced = _.throttle(((function(_this) {
          return function() {
            return _.delay(_this.tryCompletion);
          };
        })(this)), 100);
        this.session.selection.selectionLead.on('change', (function(_this) {
          return function(e) {
            var _ref, _ref1;
            if (e.old.row === _this.session.selection.getCursor().row) {
              if (((_ref = (_this.get('editor')).completer) != null ? _ref.active : void 0) || app.Settings.get('autocomplete')) {
                return _this.tryCompletionDebounced();
              }
            } else {
              _this.selectionchange();
              return (_ref1 = (_this.get('editor')).completer) != null ? _ref1.disable() : void 0;
            }
          };
        })(this));
        file = this.get('file');
        file.on('change:mtime', this.filedidchange);
        file.save({
          edit: true
        });
        return this.set({
          lastSelectTime: new Date()
        });
      },
      tryLoadStartupData: function() {
        var data;
        if (!app.console.startupData) {
          return;
        }
        data = _.find(app.console.startupData, (function(_this) {
          return function(data) {
            return data.url === _this.get('url');
          };
        })(this));
        if (!data) {
          return;
        }
        if (this.session.getValue() !== data.data) {
          this.session.setValue(data.data);
        }
        this.session.selection.clearSelection();
        this.session.selection.moveCursorTo(data.position.row, data.position.column);
        this.session.setScrollLeft(data.scrollLeft);
        this.session.setScrollTop(data.scrollTop);
        return app.console.startupData = _.without(app.console.startupData, data);
      },
      onManagerUpdate: function() {
        this.selectionchange();
        return this.highlightSelectors();
      },
      onLoaded: function(_arg) {
        var data;
        data = _arg.data;
        this.session.doc.setValue(data);
        this.session.selection.setSelectionAnchor(0, 0);
        this.session.selection.moveCursorTo(0, 0);
        this.set({
          saved: true
        });
        if (!this._loaded) {
          this.session.setUndoManager(new UndoManager());
          if ('stylus' === this.get('file').get('type')) {
            require(['lib/editor/stylus'], (function(_this) {
              return function(StylusMode) {
                if (_this.modeStylus == null) {
                  _this.modeStylus = new StylusMode.Mode();
                }
                _this.session.setMode(_this.modeStylus);
                return _.delay(function() {
                  return require(['lib/editor/stylusmanager'], function(StylusManager) {
                    _this.contentManager = new StylusManager(_this);
                    _this.contentManager.on('update', _this.onManagerUpdate);
                    return _this.contentManager.on('loaded', function() {
                      if (_this._initialSelector) {
                        return _this.selectSelector.apply(_this, _this._initialSelector);
                      }
                    });
                  });
                }, 200);
              };
            })(this));
          } else {
            require(['lib/editor/css'], (function(_this) {
              return function(CSSMode) {
                if (_this.modeCSS == null) {
                  _this.modeCSS = new CSSMode.Mode();
                }
                _this.session.setMode(_this.modeCSS);
                return _.delay(function() {
                  return require(['lib/editor/cssmanager'], function(CSSManager) {
                    _this.contentManager = new CSSManager(_this);
                    _this.contentManager.on('update', _this.onManagerUpdate);
                    return _this.contentManager.on('loaded', function() {
                      if (_this._initialSelector) {
                        return _this.selectSelector.apply(_this, _this._initialSelector);
                      }
                    });
                  });
                }, 200);
              };
            })(this));
          }
          this.tryLoadStartupData();
          this._completionCursor = 0;
          _.delay((function(_this) {
            return function() {
              return require(['lib/editor/autocompleter'], function(autoCompleter) {
                return _this.autoCompleter = autoCompleter;
              });
            };
          })(this), 300);
        }
        return this._loaded = true;
      },
      filedidchange: function() {
        if (this._rememberedSelfSave) {
          return this._rememberedSelfSave = false;
        }
        return app.console.callAPI('GetFileData', {
          url: this.get('url')
        }, this.onLoaded);
      },
      onRemove: function() {
        return this.get('file').off('change:mtime', this.filedidchange);
      },
      selectionchange: function() {
        var editor, end, error, first, last, pos, rule, selector, start, _ref, _ref1;
        pos = this.session.selection.getCursor();
        error = this.get('error');
        if ((_ref = this.contentManager) != null ? _ref.complete : void 0) {
          this.session.removeMarker(this.marker);
          this.selector = null;
          rule = this.contentManager.ruleForLine(pos.row + 1);
          if (rule !== -1) {
            _ref1 = this.contentManager.rangeForRule(rule), start = _ref1.start, end = _ref1.end;
            if (end >= pos.row) {
              this.selector = rule;
              this.marker = this.session.addMarker(new Range(start - 1, 0, end, 0), 'selection-marker', 'line', true);
              editor = this.get('editor').editor;
              first = editor.getFirstVisibleRow();
              last = editor.getLastVisibleRow();
              if (this._scrollcenter && (start - 2 < first || start + 4 > last)) {
                editor.scrollToLine(start - ~~((last - first) / 4));
              } else {
                if (first > start) {
                  editor.scrollToLine(start - 1);
                } else if (end > last) {
                  editor.scrollToLine(first + end - last + 3);
                }
              }
              selector = this.contentManager.selectorTextForRule(rule);
            } else {
              selector = null;
            }
          } else {
            selector = null;
          }
          if (this._currentSelector !== selector && this.get('selected')) {
            this.trigger('selectorchange', selector);
            this._currentSelector = selector;
          }
          return this._scrollcenter = false;
        }
      },
      showCompletions: function(cursor, completions) {
        var column, editor, row, _ref, _ref1, _ref2;
        editor = this.get('editor');
        if (!completions) {
          return (_ref = editor.completer) != null ? _ref.disable() : void 0;
        }
        if (this._completionCursor !== cursor) {
          return;
        }
        _ref1 = this.session.selection.getCursor(), row = _ref1.row, column = _ref1.column;
        if (!(this.session.getLength() > row)) {
          return;
        }
        return (_ref2 = editor.completer) != null ? _ref2.activate(this, completions, row, column) : void 0;
      },
      tryCompletion: function(force) {
        var cursor, req, tokens, _ref, _ref1;
        if (force == null) {
          force = false;
        }
        if (app.console.dialogOpen) {
          return;
        }
        if (!(((_ref = this.contentManager) != null ? _ref.complete : void 0) && (this.autoCompleter != null))) {
          return;
        }
        cursor = this.session.selection.getCursor();
        tokens = (this.session.getTokens(cursor.row, cursor.row))[0].tokens;
        if (_.find(tokens, function(t) {
          return t.type === 'comment';
        })) {
          return;
        }
        req = this.contentManager.completionAtPosition(cursor);
        if (req) {
          return this.autoCompleter.complete(this.get('file').get('type'), req, _.bind(this.showCompletions, this, ++this._completionCursor));
        } else {
          return (_ref1 = (this.get('editor')).completer) != null ? _ref1.disable() : void 0;
        }
      },
      selectValueArea: function(completion) {
        var line, match, position, propname;
        position = this.session.selection.getCursor();
        line = this.session.doc.getLine(position.row);
        match = line.match(/^((\s*([a-z-]{4,})\s*:?\s*).+?)\s*;?\s*$/);
        if (!match) {
          return;
        }
        propname = match[3].toLowerCase();
        if (propname === 'strong' || propname === 'span' || propname === 'table' || propname === 'tbody' || propname === 'input' || propname === 'textarea') {
          return;
        }
        return this.session.selection.setSelectionRange(new Range(position.row, match[2].length, position.row, match[1].length));
      },
      selectNewValuePosition: function() {
        var currentline, end, indent, line, nextline, position, rule, start, _ref, _ref1;
        if (!(((_ref = this.contentManager) != null ? _ref.complete : void 0) && (this.autoCompleter != null))) {
          return;
        }
        position = this.session.selection.getCursor();
        rule = this.contentManager.ruleForLine(position.row + 1);
        if (rule === -1) {
          return;
        }
        _ref1 = this.contentManager.rangeForRule(rule), start = _ref1.start, end = _ref1.end;
        if (end < position.row) {
          return;
        }
        end--;
        line = this.session.doc.getLine(end);
        if (line.match(/^\s*}\s*$/)) {
          end--;
        }
        while (true) {
          line = this.session.doc.getLine(end);
          if (end <= start || !line.match(/^\s*$/)) {
            break;
          }
          end--;
        }
        currentline = this.session.doc.getLine(end);
        indent = (currentline.match(/^\s*/))[0];
        nextline = this.session.doc.getLine(end + 1);
        if (currentline.match(/}\s*$/)) {
          return;
        }
        if (nextline.match(/^\s*$/)) {
          this.session.doc.replace(new Range(end + 1, 0, end + 1, nextline.length), indent);
          this.session.selection.clearSelection();
          return this.session.selection.moveCursorTo(end + 1, indent.length);
        } else {
          this.session.doc.insert({
            row: end,
            column: currentline.length
          }, "\n" + indent);
          this.session.selection.clearSelection();
          return this.session.selection.moveCursorTo(end + 1, indent.length);
        }
      },
      complete: function(completion) {
        var data, endpos, isend, lastpart, line, m, position;
        position = this.session.selection.getCursor();
        if (completion.exec) {
          return completion.exec(this.get('editor'), position);
        }
        line = this.session.doc.getLine(position.row);
        isend = (line.substr(position.column)).match(/^\s*$/);
        data = completion.value;
        if (isend && completion.property) {
          if (this.get('file').get('type') === 'stylus') {
            data += ' ';
          } else {
            data += ': ';
          }
        }
        if (completion.sfx) {
          data += completion.sfx;
        }
        if (completion.pfx) {
          data = completion.pfx + data;
        }
        this.session.doc.replace(new Range(position.row, position.column - completion.offset, position.row, position.column + (completion.padd || 0)), data);
        if (completion.cursor) {
          this.session.selection.moveCursorBy(0, completion.cursor);
        }
        if (!isend && completion.property) {
          position = this.session.selection.getCursor();
          line = this.session.doc.getLine(position.row);
          lastpart = line.substr(position.column);
          m = lastpart.match(/^[\s:]+/);
          if (m) {
            this.session.selection.moveCursorBy(0, m[0].length);
            endpos = line.length;
            if (line[endpos - 1] === ';') {
              endpos--;
            }
            return this.session.selection.setSelectionAnchor(position.row, endpos);
          }
        }
      },
      selectSelector: function(selector, index, property) {
        var rule, _ref;
        if (index == null) {
          index = 0;
        }
        if (property == null) {
          property = null;
        }
        if (!((_ref = this.contentManager) != null ? _ref.complete : void 0)) {
          return this._initialSelector = [selector, index, property];
        }
        rule = this.contentManager.ruleForSelectorText(selector, index);
        if (rule !== -1) {
          this._scrollcenter = true;
          return this.markSelector(rule, property);
        }
      },
      close: function() {
        var file;
        if (!this.get("saved")) {
          app.console.callAPI('PublishSaved', {
            url: this.get('url')
          });
        }
        file = this.get('file');
        file.save({
          edit: false
        });
        return this.destroy();
      },
      tryClose: function() {
        if (this.get('saved')) {
          return this.close();
        } else {
          return require(['lib/views/ui/popup'], (function(_this) {
            return function(Popup) {
              return new Popup({
                msg: "Do you want to save the changes you made in file \"" + (_this.get('name')) + "\"?",
                buttons: [
                  {
                    id: 'no',
                    txt: 'Don\'t save',
                    exec: function() {
                      return _this.close();
                    }
                  }, {
                    id: 'cancel',
                    txt: 'Cancel',
                    exec: function() {
                      return _this.get('editor').focus();
                    }
                  }, {
                    id: 'yes',
                    txt: 'Save',
                    highlight: true,
                    exec: function() {
                      return _this.get('editor').save(_this, function() {
                        return _this.close();
                      });
                    }
                  }
                ]
              });
            };
          })(this));
        }
      },
      moveSelector: function(delta) {
        var rule;
        if (this.selector) {
          rule = this.selector;
        } else {
          rule = this.contentManager.ruleForLine(this.session.selection.getCursor().row + 1);
        }
        if (delta === -1) {
          if (this.selector) {
            rule = this.contentManager.previousRule(rule - 1);
          }
        } else {
          rule = this.contentManager.nextRule(rule);
        }
        if (rule === -1) {
          return;
        }
        return this.markSelector(rule);
      },
      markSelector: function(rule, property) {
        var end, lastcol, m, match, mm, parts, pos, properties, row, start, _i, _len, _ref, _ref1;
        if (property == null) {
          property = null;
        }
        if (!((_ref = this.contentManager) != null ? _ref.complete : void 0)) {
          return;
        }
        pos = null;
        if (property) {
          properties = [property];
          if (property.match(/^\-[a-z]+\-/i)) {
            parts = property.split('-');
            parts = parts.slice(2);
            properties.push(parts.join('-'));
          }
          _ref1 = this.contentManager.rangeForRule(rule), start = _ref1.start, end = _ref1.end;
          while (start <= end) {
            row = this.session.doc.getLine(start);
            for (_i = 0, _len = properties.length; _i < _len; _i++) {
              property = properties[_i];
              match = row.match(new RegExp('^\\s*' + property, 'i'));
              if (match) {
                pos = {
                  row: start,
                  col: 0
                };
                m = row.match(/^\s*[^\s:]+\s*:?\s*/);
                if (m) {
                  pos.col = m[0].length;
                  lastcol = row.length;
                  if (mm = row.match(/;\s*$/)) {
                    lastcol -= mm[0].length;
                  }
                  this.session.selection.setSelectionAnchor(start, lastcol);
                  this.session.selection.moveCursorTo(start, pos.col);
                  return;
                }
              }
            }
            start++;
          }
        }
        if (!pos) {
          row = this.session.doc.getLine(rule - 1);
          pos = {
            row: rule - 1,
            col: (row.match(/^\s*/))[0].length
          };
        }
        this.session.selection.moveCursorTo(pos.row, pos.col);
        return this.session.selection.setSelectionAnchor(pos.row, pos.col);
      },
      highlightSelectors: function(selectors) {
        var anchor_end, anchor_start, doc, end, file, m, reposition, rule, selector, start, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4;
        if (selectors == null) {
          selectors = null;
        }
        if (!((_ref = this.contentManager) != null ? _ref.complete : void 0)) {
          return;
        }
        doc = this.session.doc;
        if (selectors !== null) {
          this.hlselectors = selectors;
        }
        if (this.hlmarkers) {
          _ref1 = this.hlmarkers;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            m = _ref1[_i];
            m[0].detach();
            m[1].detach();
            this.session.removeMarker(m[2]);
          }
        }
        this.hlmarkers = [];
        if (this.hlselectors) {
          _ref2 = this.hlselectors;
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            _ref3 = _ref2[_j], file = _ref3[0], selector = _ref3[1];
            rule = this.contentManager.ruleForSelectorText(selector);
            if (rule === -1) {
              continue;
            }
            _ref4 = this.contentManager.rangeForRule(rule), start = _ref4.start, end = _ref4.end;
            anchor_start = new Anchor(doc, start - 1, 0);
            anchor_end = new Anchor(doc, end, 0);
            m = [anchor_start, anchor_end, this.session.addMarker(Range.fromPoints(anchor_start.getPosition(), anchor_end.getPosition()), 'highlight-marker', 'line', false)];
            this.hlmarkers.push(m);
            anchor_start.marker = m;
            anchor_end.marker = m;
            reposition = _.bind(this.repositionHighlight, this, anchor_start);
            anchor_start.on('change', reposition);
            anchor_end.on('change', reposition);
          }
        }
        return this.trigger('change:highlight');
      },
      repositionHighlight: function(anchor) {
        var end, marker, start, _ref;
        _ref = anchor.marker, start = _ref[0], end = _ref[1], marker = _ref[2];
        this.session.removeMarker(marker);
        return anchor.marker[2] = this.session.addMarker(Range.fromPoints(start.getPosition(), end.getPosition()), 'highlight-marker', 'line', false);
      },
      select: function() {
        var isselected, _ref;
        isselected = !!this.get('selected');
        if (isselected) {
          return;
        }
        this.collection.each(function(t) {
          if (!!t.get('selected')) {
            return t.set({
              'selected': false
            });
          }
        });
        this.set({
          'selected': true
        });
        this.set({
          'lastSelectTime': new Date()
        });
        this.trigger('select', this);
        this.trigger('selectorchange', this._currentSelector);
        return (_ref = app.console) != null ? _ref.state.save({
          selectedUrl: this.get('url'),
          selectedType: this.get('file').get('type')
        }) : void 0;
      }
    });
    TabList = Backbone.Collection.extend({
      model: Tab,
      listen: function() {},
      initialize: function() {
        return this.on('remove', this.resetSelected, this);
      },
      comparator: function(tab) {
        return tab.get('offset');
      },
      selectedTab: function() {
        return this.find(function(t) {
          return t.get('selected');
        });
      },
      resetSelected: function() {
        var tab;
        if (this.size()) {
          tab = this.max(function(t) {
            return t.get('lastSelectTime');
          });
          return tab.select();
        } else {
          return this.trigger('empty');
        }
      }
    });
    return {
      Tab: Tab,
      TabList: TabList
    };
  });

}).call(this);
