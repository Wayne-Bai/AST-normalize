/**g
 *  Copyright 2012 Rackspace
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

var util = require('util');

var sprintf = require('sprintf').sprintf;
var misc = require('rackspace-shared-utils/lib/misc');
var reverseObject = require('rackspace-shared-utils/lib/misc').reverseObject;

var registry = require('./object_registry');
var utils = require('./utils');
var compoundColumn = require('./utils').compoundColumn;
var constants = require('./constants');
var settings = require('../settings');

/**
 * @param {Function} objtype Constructor for this object type.
 * @param {Object} attributes Attributes to set in the resulting object.
 */
var DBBase = function(objtype, attributes) {
  var name, default_value, fields;

  this._type = objtype;
  this._rowKey = null;
  this.key = null;
  this._version = this._type.operationalVersion;

  if (attributes) {
    if (attributes.hasOwnProperty('_key')) {
      this.key = attributes._key;
    }

    if (attributes.hasOwnProperty('_version')) {
      this._version = attributes._version;
    }
  }

  fields = this._getFieldsForOperationalVersion();

  for (name in fields) {
    if (fields.hasOwnProperty(name)) {
      if (attributes && attributes.hasOwnProperty(name) && attributes[name] !== null) {
        this[name] = attributes[name];
      } else {
        if (fields[name] !== null) {
          default_value = fields[name].default_value;
          if (default_value !== undefined) {
            this[name] = default_value;
          }
        }
      }
      if (this[name] === undefined) {
        this[name] = null;
      }
    }
  }
};

/**
 * Assign the default values from the field definition.
 */
DBBase.prototype._assignDefaultValues = function() {
  var name,
      fields,
      default_value;

  // Read fields for current operational version
  fields = this._getFieldsForOperationalVersion();

  // Establish default values for attributes not found in row.
  for (name in fields) {
    if (fields.hasOwnProperty(name)) {
      if (fields[name] !== null) {
        default_value = fields[name].default_value;
        if (this[name] === undefined && default_value !== undefined) {
          this[name] = default_value;
        }
      }
    }
  }
};

/**
 * Set the row key of an object.
 * @param {String} rowKey The row key of the object.
 */
DBBase.prototype.setRowKey = function(rowKey) {
  if (this._rowKey !== null && this._rowKey !== rowKey) {
    throw new Error('Attempt to change object row key');
  }

  this._rowKey = rowKey;
};

/**
 * Get the object's row key. This only works if the object was loaded from the
 * database or has been saved, otherwise it returns null.
 * @return {String} The row key of the object.
 */
DBBase.prototype.getRowKey = function() {
  return this._rowKey;
};

/**
 * Convert an object from its row representation to its object form.
 * @param {String} rowKey The row key of the object.
 * @param {String} key The key (column name) of the object.
 * @param {String} col The serialized column value.
 */
DBBase.prototype.fromDb = function(rowKey, key, col) {
  var i,
      name,
      serializer,
      default_value,
      column,
      fields,
      prefix = this._type.meta.dataPrefix || '',
      prefixedCols = this._type.meta.prefixedColNames === undefined ? true : this._type.meta.prefixedColNames;

  if (prefixedCols) {
    key = registry.removeDataPrefix(key);
  }

  this.key = key;
  this.setRowKey(rowKey);

  col = JSON.parse(col);

  // Set object current version to the one read from the database
  this._version = (col.hasOwnProperty('_version')) ? col._version : this._version;

  // Read fields for the current operational version
  fields = this._getFieldsForOperationalVersion();

  // Run migrations
  col = this._runMigrations(col);

  for (name in col) {
    if (col.hasOwnProperty(name)) {
      column = col[name];
      if (fields.hasOwnProperty(name)) {
        serializer = undefined;

        if (fields[name]) {
          serializer = fields[name].serializer;
        }

        // Deserialize the value of the column if necessary.
        if (serializer) {
          this[name] = serializer.deserialize(column);
        } else {
          this[name] = column;
        }
      }
      else if (constants.SPECIAL_FIELD_NAMES.indexOf(name) !== -1) {
        this[name] = column;
      }
    }
  }

  this._assignDefaultValues();
};

/**
 * Use the meta information on the specific object type to map to the column
 * names the hiearcical list of keys.
 * @param {Array<String>} keyArray the array of keys.
 * @param {Object} obj the parent object to optionally assign.
 */
DBBase.prototype.setParentRelationship = function(keyArray, obj) {
  keyArray = keyArray || [];

  if (keyArray.length !== this._type.meta.parents.length) {
    throw new Error('Parent keys and keyArray should be equal. ' +
                    'parents=' + this._type.meta.parents.join(',') +
                    ', keyArray=' + keyArray.join(',') + '. ' +
                    'Probably includeChildren is true for a model without ' +
                    'children objects');
  }

  var i,
      parents = this._type.meta.parents,
      leni;

  for (i = 0, leni = keyArray.length; i < leni; i++) {
    this[parents[i]] = keyArray[i];
  }

  if (obj) {
    this.parent = obj;
  }
};

/**
 * Return the parentKey by assembling the attributes based on the meta parents.
 * @return {String} return the compound column of the parent keys.
 */
DBBase.prototype.parentKey = function() {
  var i,
      parents = this._type.meta.parents,
      result = [],
      leni;

  for (i = 0, leni = parents.length; i < leni; i++) {
    result.push(this[parents[i]]);
  }

  return utils.compoundColumn(result);
};

/**
 * Generate the portion of a key that follows the prefix.
 * @return {String} The key postfix.
 */
DBBase.prototype.makeKeyPostfix = function() {
  return misc.randstr(8);
};

/**
 * get the key, this permenantly assigns the key.  This is similar to lazy
 * loading.
 * @return {String} return the key.
 */
DBBase.prototype.getKey = function() {
  if (!this.key) {
    this.key = this._type.prefix() + this.makeKeyPostfix();
  }

  return this.key;
};

/**
 * Get the natural DB key.
 * @return {String} the natural database column name.
 */
DBBase.prototype.getDbKey = function() {
  return (this._type.meta.dataPrefix || '') + this.getKey();
};


/**
 * Get fields object for the current operational version.
 *
 * @return {Object} Field for the current working version.
 */
DBBase.prototype._getFieldsForOperationalVersion = function() {
  return this._getFieldsForVersion(this._type.operationalVersion);
};

/**
 * Return a new object with the fields defined in the fields object.
 *
 * @param {Object} obj Model object.
 * @param {Object} fields Fields object.
 * @return {Object} Object with the fields defined in fields object.
 */
DBBase.prototype._getObject = function(obj, fields) {
  var name, serializer, parentPosition, result = {};

  for (name in fields) {
    if (fields.hasOwnProperty(name)) {
      serializer = undefined;

      if (fields[name]) {
        serializer = fields[name].serializer;
      }

      // Serialize the value of the column if necessary.
      if (serializer) {
        result[name] = serializer.serialize(obj[name]);
      } else {
        result[name] = obj[name];
      }
    }
  }

  return result;
};

/**
 * Get fields object for the provided version.
 *
 * @param {Number} version Migration version.
 * @return {Object} Field for the current working version.
 */
DBBase.prototype._getFieldsForVersion = function(version) {
  var migration = this._type._migrations.versions[version], fields;

  if (!migration) {
    throw new Error('Missing migration for version: ' + version);
  }

  return migration.FIELDS;
};

/**
 * Run migrations on the model and return an object at the version
 * model.operationalVersion.
 *
 * @param {Object} obj Object to migrate.
 * @return {Object} Migrated object.
 */
DBBase.prototype._runMigrations = function(obj) {
  var curVersion = this._version,
      operationalVersion = this._type.operationalVersion,
      migrations = this._type._migrations.versions,
      objToMigrate = misc.merge(obj, {}),
      i, len, version, migration;

  if (curVersion === operationalVersion) {
    // Already at the latest version
    return objToMigrate;
  }

  if (curVersion < operationalVersion) {
    // Roll forward
    for (version = (curVersion + 1); version <= operationalVersion; version++) {
      migration = migrations[version];
      objToMigrate = migration.forward(objToMigrate);
    }
  }
  else {
    // Roll backward
    for (version = curVersion; version > operationalVersion; version--) {
      migration = migrations[version];
      objToMigrate = migration.backward(objToMigrate);
    }
  }

  return objToMigrate;
};

/**
 * Convert the object from the object form to the datastore repersentation.
 * @return {Object} Converted object.
 */
DBBase.prototype.toDb = function() {
  var columns = {},
      name,
      serializer,
      parents = this._type.meta.parents || [],
      parentPosition,
      key,
      dbFields,
      fields,
      obj,
      rv = {};

  // Assign the key id and store it locally
  key = this.getKey();
  rv.parentKeys = [];

  // Fields for the current version of object stored in the database
  dbFields = this._getFieldsForVersion(this._version);
  obj = this._getObject(this, dbFields);

  // Read fields for current operational version
  fields = this._getFieldsForOperationalVersion();

  // Run migrations
  obj = this._runMigrations(obj);

  // serialize public fields
  for (name in fields) {
    if (fields.hasOwnProperty(name)) {
      serializer = undefined;
      if (fields[name]) {
        serializer = fields[name].serializer;
      }
      parentPosition = parents.indexOf(name);
      if (parentPosition !== -1) {
        rv.parentKeys[parentPosition] = obj[name];
        continue;
      }
      // Serialize the value of the column if necessary.
      if (serializer) {
        columns[name] = serializer.serialize(obj[name]);
      } else {
        columns[name] = obj[name];
      }
    }
  }

  // Set object current version to the current write version
  columns._version = this._type.operationalVersion;

  rv.key = key;
  rv.cols = columns;

  return rv;
};

/**
 * Calculate a map of index names to the keys they contain.
 * @param {BatchInsert} bi The batch insert in progress.
 * @return {Object} an object with index names as keys and lists of index keys
 *     as values.
 */
DBBase.prototype.getIndexMap = function(bi) {
  var meta = this._type.meta,
      indexes = {},
      k,
      cleaned = this.toDb();

  if (!meta.indexes) {
    return indexes;
  }

  // Populate the keys to Index
  for (k in meta.indexes) {
    if (meta.indexes.hasOwnProperty(k)) {
      indexes[k] = meta.indexes[k]._getKeys(bi, cleaned, meta);
    }
  }

  return indexes;
};

/**
 * Remove unused keys for a given index for a given object.
 * @param {Object} indexObj The index metadata object.
 * @param {Array.<string>} oldKeys The old list of keys.
 * @param {Array.<string>} newKeys The new list of keys.
 * @param {BatchInsert} batchInsert The batch insert in progress.
 */
DBBase.prototype.removeDisusedIndexes = function(indexObj, oldKeys, newKeys, batchInsert) {
  var remove = [],
      newKeyHash,
      i;

  if (oldKeys.length === 1 && newKeys.length === 1) {
    // Common case, fast path
    if (oldKeys[0] !== newKeys[0]) {
      remove = oldKeys;
    }
  } else {
    // Slow path - we reduce the new key list to a map for faster membership testing
    newKeyHash = newKeys.reduce(function(hash, key) {
      hash[key] = true;
      return hash;
    }, {});

    // See which old keys are still in the new keys list
    for (i = 0; i < oldKeys.length; i++) {
      if (!newKeyHash[oldKeys[i]]) {
        remove.push(oldKeys[i]);
      }
    }
  }

  if (remove.length > 0) {
    batchInsert.removeIndex(indexObj, remove, this, this._type.meta);
  }
};

/**
 * Merge for an update, this will potentially alter indexes if the affected
 * attributes are flagged as an index.
 * @param {DbOperationContext} ctx The context for this operation.
 * @param {Object} params The parameters to merge in.
 * @param {BatchInsert} batchInsert the batchInsert context to do operations on.
 * @param {Function} callback A callback fired with (err, self).
 */
DBBase.prototype.mergeForUpdate = function(ctx, params, batchInsert, callback) {
  var self = this, hookFunc = settings.MERGE_FOR_UPDATE_HOOK_FUNC;

  if (!hookFunc) {
    this._merge(ctx, params, batchInsert, callback);
    return;
  }

  // Run the hook before merging
  hookFunc.call(this, ctx, this, params, batchInsert, function(err, cleaned) {
    if (err) {
      callback(err);
      return;
    }

    self._merge(ctx, cleaned, batchInsert, callback);
  });
};

/**
 * Merge cleaned parameters.
 * @param {DbOperationContext} ctx The context for this operation.
 * @param {Object} cleaned The cleaned parameters hash.
 * @param {BatchInsert} batchInsert The batchInsert to do index operations on.
 * @param {Function} callback A callback fired with (err, self).
 */
DBBase.prototype._merge = function(ctx, cleaned, batchInsert, callback) {
  var k, oldIndexes, newIndexes, fields, field, defaultValue;

  // Compute old indexes
  oldIndexes = this.getIndexMap(batchInsert);

  fields = this._getFieldsForOperationalVersion();

  // Merge cleaned values
  for (k in cleaned) {
    if (cleaned.hasOwnProperty(k)) {
      if (cleaned[k] !== null) {
        this[k] = cleaned[k];
      }
      else {
        field = fields[k] || {};
        defaultValue = field.default_value;

        if (defaultValue !== undefined) {
          this[k] = defaultValue;
        }
        else {
          this[k] = cleaned[k];
        }
      }
    }
  }

  // Compute new indexes
  newIndexes = this.getIndexMap(batchInsert);

  // Remove disused indexes
  for (k in oldIndexes) {
    if (oldIndexes.hasOwnProperty(k)) {
      this.removeDisusedIndexes(this._type.meta.indexes[k], oldIndexes[k], newIndexes[k], batchInsert);
    }
  }

  batchInsert.save(this);
  callback(null, this);
};

/**
 * Get the canonicalName for this object
 * @return {string} Type name for this object.
 */
DBBase.prototype.getCanonicalName = function() {
  return this._type.meta.cname;
};

/**
 * Get the Type name for this object, as the Swiz Serializer should use.
 * @return {string} Type name for this object.
 */
DBBase.prototype.getSerializerType = function() {
  return this._type.meta.cname;
};

/**
 * Get the name of the column this object is (or will be, when saved) in.
 * @return {String} the name of the object's column.
 */
DBBase.prototype.getColumnName = function() {
  var self = this, parents;

  parents = this._type.parents().map(function(field) {
    return self[field];
  });

  return compoundColumn(parents.concat(this.getDbKey()));
};

/**
 * Attach the Dbobj inherits to the Type specified.
 * @param {Function} Type The constructor for a Type.
 * @param {String} filename Path to the file where the model is stored.
 */
exports.inheritBase = function(Type, filename) {
  util.inherits(Type, DBBase);

  Type._name = Type.meta.name;
  Type._filename = filename;
  Type._lookupByName = Type.meta.hasOwnProperty('lookupByName') ? Type.meta.lookupByName : false;
  Type.prefix = function() { return Type.meta.prefix; };
  Type.dataPrefix = function() { return Type.meta.dataPrefix || ''; };
  Type.getCanonicalName = function() { return Type.meta.cname; };
  Type.parents = function() { return Type.meta.parents; };
  Type.fullPrefix = function() { return Type.dataPrefix() + Type.prefix(); };
  Type.batchSizeMultiplier = function() { return (Type.meta.estimatedChildCount || 0) + 1; };
  Type.ttl = function() { return Type.meta.ttl; };

  /*
   * Function which returns the column key name.
   *
   * @param {Object} Object meta attributes.
   * @param {Object} obj Object to store, ({'key': key_name, 'parentKeys':[], 'cols': {...}}).
   * @return {String} Column key name.
   */
  Type.getColKeyName = function(meta, obj) {
    var keyList = [], keyStr, prefix = meta.dataPrefix || '';
    keyList = keyList.concat(obj.parentKeys);
    keyList.push(obj.key);
    keyStr = prefix + compoundColumn(keyList);

    return keyStr;
  };

  if (Type.meta.hasOwnProperty('getColKeyName')) {
    Type.getColKeyName = Type.meta.getColKeyName;
  }

  // This stays at the bottom
  registry.register(Type);
};


/**
 * Return the path component of the URL without a version prefix.
 * @return {String} path component of the URL (without the API version prefix).
 */
DBBase.prototype.getUrlPath = function() {
  return sprintf('/%s/%s', this.getCanonicalName(), this.getKey());
};

/**
 * Return a version which can be serialized by logmagic.
 *
 * @return {Object} Object which can be used with log magic.
 */
DBBase.prototype.toLogMagic = function() {
  var fields = this._getFieldsForOperationalVersion(),
      name, value, result = {};

  result.key = this.getKey();

  for (name in fields) {
    if (fields.hasOwnProperty(name)) {
      value = this[name];
      result[name] = value;
    }
  }

  return result;
};

/**
 * Base database class that each object inherits from that touches the db
 */
exports.DBBase = DBBase;
