/**
 *  Copyright 2012 Rackspace
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

var util = require('util');
var EventEmitter = require('events').EventEmitter;

var async = require('async');
var sprintf = require('sprintf').sprintf;
var log = require('logmagic').local('lib.orm.iterator');
var misc = require('rackspace-shared-utils/lib/misc');

var getObject = require('./object_registry').getObject;
var getObjectForDefinitionAndKey = require('./object_registry').getObjectForDefinitionAndKey;
var removeDataPrefix = require('./object_registry').removeDataPrefix;
var registry = require('./object_registry');
var errors = require('../errors');

var settings = require('../settings');
var getConnPool = require('./utils').getConnPool;
var compoundColumn = require('./utils').compoundColumn;
var explodeColumn = require('./utils').explodeColumn;
var makeColNameConverter = require('./utils').makeColNameConverter;
var buildPlaceholderString = require('./utils').buildPlaceholderString;
var getEndingPrefix = require('./utils').getEndingPrefix;
var getIndexRowKey = require('./utils').getIndexRowKey;
var constants = require('./constants');
var END_TOKEN = require('./constants').END_TOKEN;
var REMOVED_FIELD = require('./constants').SPECIAL_FIELDS.removed;
var INDEX_KEY_DELIM = require('./constants').INDEX_KEY_DELIM;

/**
 * Base iterator class.
 *
 * @param {DbOperationContext} ctx The context to pass in.
 * @constructor
 */
function BaseIterator(ctx) {
  ctx = ctx || {};

  EventEmitter.call(this);

  this._ctx = ctx;
  this._endOrErrorEmitted = false;
  this._childIterators = [];
  this._closed = false;
}

util.inherits(BaseIterator, EventEmitter);

/**
 * Register an iterator to be closed when this iterator is.
 * @param {BaseIterator} iter The iterator to be registered.
 */
BaseIterator.prototype._addChildIterator = function(iter) {
  this._childIterators.push(iter);
};

/**
 * Close this iterator and all of its children so that no further queries
 * will be performed.
 */
BaseIterator.prototype.close = function() {
  var i;

  for (i = 0; i < this._childIterators.length; i++) {
    this._childIterators[i].close();
  }

  this._closed = true;
};

/**
 * Emit an 'object' event.
 *
 * @param {DBBase} obj Object to emit.
 * @return {Boolean} true if the object has been emitted, false otherwise.
 */
BaseIterator.prototype._emitObject = function(obj) {
  this.emit('object', obj);
  return true;
};

/**
 * Emit an 'object' event and increase total counter if the object has been
 * emitted.
 *
 * @param {DBBase} obj Object to emit.
 * @return {Boolean} true if the object has been emitted, false otherwise.
 */
BaseIterator.prototype._emitObjectAndIncrementTotal = function(obj) {
  var emitted = this._emitObject(obj);

  if (emitted) {
    this.total++;
  }

  return emitted;
};

/**
 * Determine if the object should be included in the resulting set.
 *
 * @param {Function} obj Object to check.
 * @return {Boolean} true if the object should be included, false otherwise.
 */
BaseIterator.prototype._includeObject = function(obj) {
  return true;
};

/**
 * Emit an 'error' event but only if 'end' or 'error' hasn't been emitted yet.
 *
 * @param {Error} err Error object.
 */
BaseIterator.prototype._emitError = function(err) {
  if (!this._endOrErrorEmitted) {
    this._endOrErrorEmitted = true;
    this.emit('error', err);
  }
  else {
    log.dbg('_emitError called multiple times', {ctx: this._ctx, err: err});
  }
};

/**
 * Emit an 'end' event but only if 'end' or 'error' hasn't been emitted yet.
 *
 * @param {?Object} data Optional data.
 */
BaseIterator.prototype._emitEnd = function(data) {
  if (!this._endOrErrorEmitted) {
    this._endOrErrorEmitted = true;
    this.emit('end', data);
  }
  else {
    log.dbg('_emitEnd called multiple times', {ctx: this._ctx});
  }
};

/**
 * Create a new ColumnIterator, this is used as a low level iterator interface
 * for providing column slicing operations with an eventemitter interface (most
 * of the time).  This uses the objectdefinition interface to make it easier for
 * filtering with different object types.  For instance, Entity uses a _en for
 * it's data prefix.  This is known to the column iterator.
 *
 * @constructor
 * @param {DbOperationContext} ctx The context to pass in.
 * @param {String} cf Column family to operate on.
 * @param {?Object} options Object of options with the following keys:
 * consistency, batchSize, reverse, dataPrefix.
 */
var ColumnIterator = function(ctx, cf, options) {
  options = options || {};

  this._cf = cf;
  this._dataPrefix = options.dataPrefix || '';
  this._first = true;
  this._batchSize = (options.batchSize !== undefined) ? options.batchSize : 100;
  this._reverse = options.reverse;

  this._readConsistency = options.readConsistency || settings.DEFAULT_READ_CONSISTENCY;
  this._writeConsistency = options.writeConsistency || settings.DEFAULT_WRITE_CONSISTENCY;

  this.total = 0;

  if (this._batchSize < 2) {
    log.warn('ColumnIterator with batchSize < 2 created, using 2 instead', {
      ctx: ctx,
      batchSize: this._batchSize
    });
    this._batchSize = 2;
  }

  BaseIterator.call(this, ctx);
};

util.inherits(ColumnIterator, BaseIterator);

function checkValidResult(result) {
  var rowCount = result.rowCount(), colCount, row = 0;
  if (!result || result.rowCount() === 0) {
    return 0;
  }

  // Need to handle a case when a row has no columns and there are multiple rows
  colCount = result[row].cols.length;
  while (colCount === 0 && row < rowCount) {
    colCount = result[row].cols.length;
    row++;
  }

  return colCount;
}

/**
 * Iterate over a slice of columns on a single or multiple rows.
 *
 * @param {?Array} keys Optional keys to operate on. If provided it only
 * operated on those rows.
 * @param {Object} options will contain:
 * 1. starting     (string, optional) used as the start column name in the slice operation. in the absense of stop
 *                 this field acts as a startswith (e.g.: select blah* ...). Prefixing is automatically handled for you.
 * 2. ending       (string, optional) used as the stop column name in the slice operation.
 *                 If start===stop, we assume you are querying a single column and construct an appropriate query.
 * 3. colNameConverter.
 */
ColumnIterator.prototype.getSlice = function(keys, options) {
  options = options || {};
  var self = this,
      query,
      resultCount = this._batchSize,
      _end = '',
      _start,
      argBuilder,
      iteration = 0,
      singleCol,
      colNameConverter = options.colNameConverter || function(name) { return name; },
      lastElem = null,
      i, leni;

  options = options || {};
  singleCol = options.starting && options.ending && options.starting === options.ending;
  options.starting = options.starting || '';

  // Build on the object definition, start the search with the combined object
  // and passed in prefix.
  _start = self._dataPrefix + options.starting;

  if (keys && !(keys instanceof Array)) {
    keys = [keys];
  }

  if (!options.ending) {
    _end = _start + END_TOKEN;
  } else {
    _end = self._dataPrefix + options.ending;
  }

  if (singleCol) {
    query = 'SELECT ? from ? USING CONSISTENCY ' + self._readConsistency;
    argBuilder = function() {
      var args = [_start, self._cf];

      if (keys) {
        args = args.concat(keys);
      }

      return args;
    };
  } else {
    // true slice.
    query = 'SELECT FIRST ' + this._batchSize + ' ';
    if (this._reverse) {
      query += 'REVERSED ';
    }
    query += '?..? FROM ? USING CONSISTENCY ' + self._readConsistency;
    argBuilder = function() {
      var args;

      if (self._reverse) {
        args = [_end, _start, self._cf];
      } else {
        args = [_start, _end, self._cf];
      }

      if (keys) {
        args = args.concat(keys);
      }

      return args;
    };
  }

  if (keys && keys.length > 0) {
    if (keys.length === 1) {
      query += ' WHERE KEY = ?';
    }
    else {
      query += ' WHERE KEY IN (';
      query += buildPlaceholderString(keys.length);
      query += ')';
    }
  }

  async.until(
      function truthTest() {
        iteration += 1;
        return (self._closed || resultCount < self._batchSize);
      },

      function evaluateQuery(callback) {
        var name, el, cols;

        log.trace('getSlice', {
          ctx: self._ctx,
          query: query,
          start: _start,
          end: _end,
          columnFamily: self._cf,
          keys: keys,
          iteration: iteration,
          singleCol: singleCol
        });

        getConnPool().execute(self._ctx, query, argBuilder(), function(err, result) {
          if (err) {
            callback(err);
            return;
          }

          resultCount = checkValidResult(result);

          if (resultCount === 0) {
            callback();
            return;
          }

          cols = result[0].cols;

          // If not the first "pass" then shift off the first element.
          if (!self._first) {
            el = cols.shift();
            log.debug('Throwing away duplicate element "' + el.name + '"', {ctx: self._ctx});
          } else {
            self._first = false;
          }

          // NOTE: we don't re-assign resultCount here, as it represents only
          // how many results were actually returned from the database. We need
          // this value unmodified in order to establish whether we have
          // exhausted available values in the database in truthTest. This
          // iterator will not stop until less values are returned in a batch
          // than were requested. As a consequence of this, use cols.length
          // from here on to access the actual number of columns we still have.

          // Ghost rows can return back, so make sure there are columns.
          self.total += cols.length;
          self._emitColumnsFromRows(result);

          if (cols.length > 0) {
            name = result[0].cols[cols.length - 1].name;
            name = colNameConverter(name);

            if (self._reverse) {
              _end = name;
            } else {
              _start = name;
            }
          }

          callback();
        });
      },

      function(err) {
        if (err) {
          self._emitError(err);
          return;
        }

        self._emitEnd();
      }
  );
};

/**
 * Pass in a list of column names to retrieve in a single row.  This is the
 * column names version of the interface, if you refer to the thrift
 * documentation.
 *
 * @param {String} key the key of the row to look in.
 * @param {Array} colArray the array of column names to pull out of the
 *                database, there is no object type inferences made to add or
 *                remove a dataPrefix.
 */
ColumnIterator.prototype.getColumnListByKey = function(key, colArray) {
  var limit = this._batchSize,
      query,
      start = 0,
      resultCount = limit,
      replace,
      result,
      left, i,
      params = [],
      self = this;

  async.until(
      function truthTest() {
        return (self._closed || resultCount < self._batchSize);
      },
      function evaluteQuery(callback) {
        if (colArray.length >= limit) {
          left = colArray.slice(start, start + limit);
        } else {
          left = colArray;
        }

        if (left.length === 0) {
          resultCount = 0;
          callback();
          return;
        }

        // Better way to do this?
        replace = new Array(left.length);
        for (i = 0; i < left.length; i++) {
          replace[i] = '?';
        }

        if (left.length === 1) {
          // Optimization: Do a SELECT one instead of a slice query
          query = 'SELECT ? FROM ? USING CONSISTENCY ' + self._readConsistency +
              ' WHERE KEY = ?';
        }
        else {
          query = 'SELECT FIRST ' + limit + ' ' + replace.join(', ') + ' FROM ? USING CONSISTENCY ' + self._readConsistency +
              ' WHERE KEY = ?';
        }

        getConnPool().execute(self._ctx,
            query,
            left.concat([self._cf, key]),
            function(err, result) {
              if (err) {
                callback(err);
                return;
              }
              if (!result || result.rowCount() === 0) {
                resultCount = 0;
                callback();
                return;
              }
              resultCount = result[0].cols.length;
              self.total += resultCount;
              start += resultCount;
              self._emitColumnsFromRows(result);
              callback();
            });
      },
      function(err) {
        if (err) {
          self._emitError(err);
          return;
        }
        self._emitEnd();
      }
  );
};

/**
 * Get a single column.  This is useful for calls that involve pulling a single
 * column only.
 *
 * @param {String} key the key to operate on.
 * @param {String} cn the name of the column to retrieve.
 * @param {Function} callback Callback called with (err, col).
 */
ColumnIterator.prototype.getOneColumn = function(key, cn, callback) {
  var query = 'SELECT ? FROM ? USING CONSISTENCY ' + this._readConsistency +
              ' WHERE KEY = ?',
      self = this,
      count,
      args;

  // Build on the object definition, start the search
  cn = self._dataPrefix + cn;
  args = [cn, self._cf, key];

  getConnPool().execute(self._ctx, query, args, function(err, result) {
    if (err) {
      callback(err);
      return;
    }

    count = checkValidResult(result);
    if (count > 1) {
      callback(new Error('Too many objects returned back ' + result[0].cols.length));
      return;
    } else if (count === 0) {
      callback();
      return;
    }
    callback(null, result[0].cols[0]);
  });
};

/**
 * Retrieve last column from a row.
 *
 * @param {String} key Row key.
 * @param {Function} callback Callback called (err, col).
 */
ColumnIterator.prototype.getLastColumn = function(key, callback) {
  var query, count, args;

  query = "SELECT FIRST 1 REVERSED ''..'' FROM ? USING CONSISTENCY " + this._readConsistency + " WHERE KEY = ?";

  args = [this._cf, key];

  getConnPool().execute(this._ctx, query, args, function(err, result) {
    var col = null;

    if (err) {
      callback(err);
      return;
    }

    count = checkValidResult(result);

    if (count === 1) {
      col = result[0].cols[0];
    }

    callback(null, col);
  });
};

/**
 * emit all columns from a set of rows
 * @param {Array<Objects>} rows the rows from cassandra.
 */
ColumnIterator.prototype._emitColumnsFromRows = function(rows) {
  var obj, i, j, leni, lenj, row, col;

  for (i = 0, leni = rows.length; i < leni; i++) {
    row = rows[i];
    this.emit('row', row);
    for (j = 0, lenj = row.cols.length; j < lenj; j++) {
      col = row.cols[j];
      this.emit('column', col);
    }
  }
};


/**
 * Create a new RowPaginatedIndexIterator, this is used as a low level iterator interface
 * for providing column slicing operations atop an index.
 *
 * @constructor
 * @param {DbOperationContext} ctx The context to pass in.
 * @param {String} cf Column family to operate on.
 * @param {?Object} options Object of options with the following keys:
 * consistency, batchSize, reverse, dataPrefix.
 */
var RowPaginatedIndexIterator = function(ctx, cf, options) {
  options = options || {};

  this._cf = cf;
  this._dataPrefix = options.dataPrefix || '';
  this._first = true;
  this._batchSize = (options.batchSize !== undefined) ? options.batchSize : 100;
  this._reverse = options.reverse;

  this._readConsistency = options.readConsistency || settings.DEFAULT_READ_CONSISTENCY;
  this._writeConsistency = options.writeConsistency || settings.DEFAULT_WRITE_CONSISTENCY;

  this.total = 0;

  if (this._batchSize < 2) {
    log.warn('RowIterator with batchSize < 2 created, using 2 instead', {
      ctx: ctx,
      batchSize: this._batchSize
    });
    this._batchSize = 2;
  }

  BaseIterator.call(this, ctx);
};

util.inherits(RowPaginatedIndexIterator, BaseIterator);


/**
 * Format the value
 * @param value {String}
 * @return {String} The value, formatted
 */
RowPaginatedIndexIterator.prototype.formatValue = function(value) {
  return value;
};


/**
 * Get a single row.  This is useful if you want to de-reference an index
 * without pulling the whole record.
 *
 * @param {String} key the key to operate on.
 * @param {Function} callback Callback called with (err, col).
 */
RowPaginatedIndexIterator.prototype.getOneIndexRow = function(key, callback) {
  var query = 'SELECT * FROM ? USING CONSISTENCY ' + this._readConsistency +
              ' WHERE KEY = ?',
      self = this,
      count,
      cn,
      args;

  // Build on the object definition, start the search
  cn = self._dataPrefix + key;
  args = [self._cf, cn];

  getConnPool().execute(self._ctx, query, args, function(err, result) {
    if (err) {
      callback(err);
      return;
    }
    count = result.length;
    if (count > 1) {
      callback(new Error('Too many objects returned back ' + result[0].cols.length));
      return;
    } else if (count === 0) {
      callback();
      return;
    }
    callback(null, self.formatValue(result[0].cols[0]));
  });
};

/**
 * Iterate over a slice of rows
 *
 * @param {Object} options will contain:
 * 1. starting     (string, optional) used as the start column name in the slice operation. in the absense of stop
 *                 this field acts as a startswith (e.g.: select blah* ...). Prefixing is automatically handled for you.
 * 2. limit        {number, optional}
 * @param {Function} callback Function to callback on completion (err, entity, data)
 */
RowPaginatedIndexIterator.prototype.getIndexSlice = function(options, callback) {
  var self = this,
      query,
      limit,
      lastElem = null;

  options = options || {};
  limit = (options.limit !== undefined) ? options.limit + 1 : this._batchSize + 1;

  var args = [self._cf];
  
  query = 'SELECT * FROM ? USING CONSISTENCY ' + self._readConsistency;
  if (options.hasOwnProperty('starting')) {
    query = query + ' WHERE KEY >= ? ';
    args.push(self._dataPrefix + options.starting);
  }
  query = query + ' LIMIT ' + limit + ';';

  log.trace('getSlice', {
    ctx: self._ctx,
    query: query,
    columnFamily: self._cf
  });

  getConnPool().execute(self._ctx, query, args, function(err, result) {
    if (err) {
      callback(err);
      return;
    }
    var cols = [], len = result.length, last;
    result.forEach(function(val) {
      if (val.cols.length !== 0) {
        cols.push({value: self.formatValue(val.cols[0].name), key: val.key});
      }
    });
    if (len >= limit) {
      last = cols.pop();
      callback(err, cols, {nextKey: last.key});
      return;
    }
    callback(err, cols, {});
  });
};


/**
 * Construct a new object iterator that populates objects from a column
 * iterator, it uses the data mapping to hide the complexity.  It relies on
 * looking at the Meta information for the type passed to the constructor.  It
 * deduces columnFamily to use and other cassandra specific information.
 *
 * @constructor
 * @param {DbObjectContext} ctx the context to use.
 * @param {Object} objectDefinition the object definition of the data mapping
 *        relationship.
 * @param {Object} options the hash of options to pass in.
 */
var BaseObjectIterator = function(ctx, objectDefinition, options) {
  options = options || {};
  this._objectDefinition = objectDefinition;
  this._options = options || {};

  if (!this._options.hasOwnProperty('dataPrefix') && this._objectDefinition && this._objectDefinition.meta) {
    this._options.dataPrefix = this._objectDefinition.meta.dataPrefix;
  }

  this.total = 0;
  BaseIterator.call(this, ctx);
};
util.inherits(BaseObjectIterator, BaseIterator);

/**
 * expand the columns so they go from this:
 *  ['enA:chB:bcA'] -> ['enA', 'enA:chB', 'enA:chB:bcA']
 *
 *  @param {Array} colArray the array of columns to convert.
 *  @param {Boolean} noRelationships should you actually do the conversion.
 *  @return {Array} modified array.
 */
BaseObjectIterator.prototype._expandColumns = function(colArray, noRelationships) {
  var expandedColumns = [],
      keyCols,
      i, j,
      last = [],
      key,
      obj;

  if (noRelationships) {
    return colArray;
  }

  for (i = 0; i < colArray.length; i++) {
    keyCols = colArray[i];

    // TODO: Should probably be two methods
    // todo: does this need to be addressed with column name conversion?
    if (!(keyCols instanceof Array)) {
      keyCols = explodeColumn(colArray[i]);
    }

    for (j = 1; j < keyCols.length + 1; j++) {
      obj = getObjectForDefinitionAndKey(this._objectDefinition, keyCols[j - 1]);

      key = obj.dataPrefix() + compoundColumn(keyCols.slice(0, j));
      if (last[j - 1] !== key) {
        expandedColumns.push(key);
        last[j - 1] = key;
      }
    }
  }

  return expandedColumns;
};


/**
 * Get exactly one object from exactly one column. Does not query or set children or parent.
 *
 * @param {String} rowKey The key for the row the object is in.
 * @param {Array} parentKeys An array of keys of parent objects which are strings.
 * @param {String} objKey The key for the object to get.
 * @param {Function} callback A function called with (err, data).
 */
BaseObjectIterator.prototype.getOneObject = function(rowKey, parentKeys, objKey, callback) {
  var ci = new ColumnIterator(this._ctx, this._objectDefinition.meta.columnFamily, this._options),
      cn = compoundColumn(parentKeys.concat(objKey)),
      self = this;

  this._addChildIterator(ci);
  ci.getOneColumn(rowKey, cn, function(err, col) {
    if (err) {
      callback(err);
      return;
    }
    if (!col) {
      callback();
      return;
    }
    callback(null, self._newObject(rowKey, objKey, col.value.toString('utf8')));
  });
};


/**
 * Retrieve last object from a row.
 *
 * @param {String} rowKey The key for the row the object is in.
 * @param {Function} callback Callback called with (err, obj).
 */
BaseObjectIterator.prototype.getLastObject = function(rowKey, callback) {
  var ci = new ColumnIterator(this._ctx, this._objectDefinition.meta.columnFamily, this._options),
  self = this;

  ci.getLastColumn(rowKey, function(err, col) {
    if (err) {
      callback(err);
      return;
    }

    if (!col) {
      callback(null, null);
      return;
    }

    callback(null, self._newObject(rowKey, col.name, col.value.toString('utf8')));
  });
};


/**
 * Get one object and all children.
 *
 * @param {String} rowKey The key for the row the object is in.
 * @param {Array} parentKeys An array of keys of parent objects which are strings.
 * @param {String} objKey The key for the object to get.
 */
BaseObjectIterator.prototype.getObjectAndChildren = function(rowKey, parentKeys, objKey) {
  var self = this, parent, childrenIter;

  // If there isn't a data prefix on the parent type, we don't want to use one,
  // and if there is a data prefix, we don't want to use it for the children slice query.
  childrenIter = new ObjectIterator(this._ctx, this._objectDefinition, {dataPrefix: false});
  this._addChildIterator(childrenIter);

  if (this._objectDefinition.dataPrefix) {
    // the parent will not be included in the slice below, we have to get it separately
    this.getOneObject(rowKey, parentKeys, objKey, function(err, object) {
      if (err) {
        self._emitError(err);
        return;
      }
      parent = object;
      childrenIter.getSliceByKey(rowKey, false, objKey, objKey + END_TOKEN);
    });
  } else {
    // the parent will be included in this slice
    childrenIter.getSliceByKey(rowKey, false, objKey, objKey + END_TOKEN);
  }

  childrenIter.on('object', function(obj) {
    var field;
    // getSliceByKey() will return 1 object with children objects populated,
    // *even if* the parent object was not present in the slice (it will get defaults)
    // so if the real parent is set, return that instead, after setting the children.
    if (parent) {
      for (field in obj) {
        if (obj.hasOwnProperty(field) && obj[field] instanceof Array && !obj._type.fields.hasOwnProperty(field)) {
          // Any array belonging to a model which is not listed as a field
          // is an array of child objects. Transfer it to the real parent.
          parent[field] = obj[field];
        }
      }
    } else {
      parent = obj;
    }
    self._emitObjectAndIncrementTotal(parent);
  });
  childrenIter.on('error', this._emitError.bind(this));
  childrenIter.on('end', function() {
    // process.nextTick() must be used here in case 'object' and 'end' are handled within the same tick.
    process.nextTick(function() {
      if (self.total === 0) {
        // this means this parent object has no children
        self._emitObject(parent);
      }
      self._emitEnd();
    });
  });
};


/**
 * Get only requested objects over a key, potentially include parent objects
 * when you build the result set.
 *
 * @param {String} key Key of the object to retrieve.
 * @param {Array} colArray the list of columns to pull out.
 * @param {Boolean} noRelationships include building the relationships.
 */
BaseObjectIterator.prototype.getColumnListByKey = function(key, colArray, noRelationships) {
  var columnIter = new ColumnIterator(this._ctx, this._objectDefinition.meta.columnFamily, this._options),
      self = this,
      currentObjs = [],
      depth = this._objectDefinition.parents().length,
      colNameConverter = makeColNameConverter(self._objectDefinition, true);

  this._addChildIterator(columnIter);
  log.trace('Depth for object def.', { ctx: this._ctx, depth: depth, name: this._objectDefinition._name });

  colArray = this._expandColumns(colArray, noRelationships);
  columnIter.getColumnListByKey(key, colArray);

  columnIter.on('column', function(col) {
    var keyCols,
        keyPart,
        i, leni,
        emitObj,
        obj;

    keyCols = colNameConverter(col.name);
    for (i = 0, leni = keyCols.length; i < leni; i++) {
      keyPart = keyCols[i] = removeDataPrefix(keyCols[i]);
      // If the key hasn't been tracked yet, this assumes that the parent comes
      // first
      if (!currentObjs[i] || currentObjs[i].key !== keyPart) {
        emitObj = currentObjs[i];
        currentObjs[i] = obj = self._newObject(key, keyPart, col.value.toString('utf8'));
        // Build the parent/child relationships only if we ask for it.
        if (i > 0 && !noRelationships) {
          obj.setParentRelationship(keyCols.slice(0, i), currentObjs[i - 1]);
          var newObj = currentObjs[i - 1][obj._type.getCanonicalName()];

          if (newObj) {
            newObj.push(obj);
          } else {
            currentObjs[i - 1][obj._type.getCanonicalName()] = [obj];
          }
        }
        if (i === depth) {
          // Emit at the end of a new object not the beginning, if we wanted the
          // beginning we would emit "obj"
          if (emitObj) {
            self.total++;
            self._emitObject(emitObj);
          }
        }
      }
    }
  });

  columnIter.on('error', function(err) {
    self._emitError(err);
  });

  columnIter.on('end', function() {
    var emitObj = currentObjs[depth];

    if (emitObj) {
      self._emitObjectAndIncrementTotal(emitObj);
    }

    self._emitEnd();
  });
};

/**
 * Get all objects over a key.
 * @param {string} key key of the object to retrieve.
 * @param {boolean} noIncludeChildren don't include building the children relationships.
 * @param {string} starting column to start slicing on.
 * @param {string} ending (optional) slice to end with. if not present starting is treated as a wildcard.
 */
BaseObjectIterator.prototype.getSliceByKey = function(key, noIncludeChildren, starting, ending) {
  this._getSlice(key, noIncludeChildren, starting, ending);
};

/**
 * Get all objects over a slice.
 * @param {Boolean} noIncludeChildren don't include building the children relationships.
 * @param {String} starting column to start slicing on.
 * @param {String} ending (optional) slice to end with. If not present starting is treated as a wildcard.
 */

BaseObjectIterator.prototype.getSlice = function(noIncludeChildren, starting, ending) {
  this._getSlice(null, noIncludeChildren, starting, ending);
};

/**
 * Get all objects over a slice.
 * @param {?String} key Optional key of the object to retrieve.
 * @param {Boolean} noIncludeChildren don't include building the children relationships.
 * @param {String} starting column to start slicing on.
 * @param {String} ending (optional) slice to end with. If not present starting is treated as a wildcard.
 */
BaseObjectIterator.prototype._getSlice = function(key, noIncludeChildren, starting, ending) {
  var self = this,
      depth = this._objectDefinition.parents().length,
      colNameConverter = makeColNameConverter(this._objectDefinition, true);

  // Default to true, probably doesn't work
  log.trace('Depth for object def.', { ctx: this._ctx, depth: depth, name: this._objectDefinition._name });

  try {
    ending = getEndingPrefix(this._objectDefinition, !noIncludeChildren, starting, ending);
  }
  catch (err) {
    process.nextTick(this._emitError.bind(this, new errors.InvalidKeyPrefixError(this._objectDefinition, ending)));
    return;
  }

  function getSlice(starting, ending) {
    var columnIter,
        currentObjs = [],
        keys = (key) ? [key] : null;

    columnIter = new ColumnIterator(self._ctx, self._objectDefinition.meta.columnFamily, self._options);
    self._addChildIterator(columnIter);
    columnIter.getSlice(keys, {starting: starting, ending: ending,
      colNameConverter: makeColNameConverter(self._objectDefinition, false)});

    columnIter.on('column', function(col) {
      var keyPart,
          keyCols,
          leni,
          i,
          emitObj,
          obj, Def;

      // Object looks something like this:
      // { value: '{'label':234,'account_id':'aFoo','ip_addresses':null,'metadata':null}', name: '_en0BLL1iAp:chA' }
      // uuids are handled a bit differently: check for _bytes attr and use that.
      // todo: should cass client be sending up a buffer instead. It's what I expect.
      keyCols = colNameConverter(col.name._bytes || col.name, true);
      // Start at the depth of the column definition for which this iterator was
      // created, we can't take the shortcut we did with the column list, since we
      // can't always get the parent key when slicing columns.
      for (i = depth, leni = keyCols.length; i < leni; i++) {
        keyPart = keyCols[i];
        // If the key hasn't been tracked yet
        if (!currentObjs[i] || currentObjs[i].key !== keyPart) {
          emitObj = currentObjs[i];
          // When doing a slice like 'paAA'..'paZZ' looking for Child objects,
          // if the Parent object has a data prefix it doesn't make sense to
          // try to use db values to construct the parent (this tends to break
          // migrations very badly). Instead, construct an "empty" parent. It
          // is up to the caller to throw it away and replace it with the real
          // one.
          Def = getObjectForDefinitionAndKey(self._objectDefinition, keyPart);
          if (Def.meta.dataPrefix && keyPart.indexOf(Def.meta.dataPrefix) !== 0) {
            currentObjs[i] = obj = new Def({_key: keyPart});
          } else {
            currentObjs[i] = obj = self._newObject(key, keyPart, col.value.toString('utf8'));
          }

          if (i === depth) {
            obj.setParentRelationship(keyCols.slice(0, i), currentObjs[i - 1]);

            // Emit at the end of a new object not the beginning, if we wanted the
            // beginning we would emit "obj"
            if (emitObj) {
              self._emitObjectAndIncrementTotal(emitObj);
            }

            // Build the child relationships only if we ask for it.
          } else if (!noIncludeChildren) {
            var siblings = currentObjs[i - 1][obj._type.getCanonicalName()];

            if (self._includeObject(obj)) {
              obj.setParentRelationship(keyCols.slice(0, i), currentObjs[i - 1]);

              if (siblings) {
                siblings.push(obj);
              } else {
                currentObjs[i - 1][obj._type.getCanonicalName()] = [obj];
              }
            }
            else if (!siblings) {
              // Always create the array even if the are no children
              currentObjs[i - 1][obj._type.getCanonicalName()] = [];
            }
          }
        }
      }
    });

    columnIter.on('error', function(err) {
      self._emitError(err);
    });

    columnIter.on('end', function(data) {
      var emitObj = currentObjs[depth];

      if (emitObj) {
        self._emitObjectAndIncrementTotal(emitObj);
      }

      self._emitEnd();
    });
  }

  getSlice(starting, ending);
};

/**
 * Make an object from the mapping of getObject, then use it to pull in the data
 * and map the keys.
 *
 * @param {String} key The row key the object came from.
 * @param {String} cn the column name.
 * @param {String} val String value of the column.
 * @return {dbu} return a new definition.
 */
BaseObjectIterator.prototype._newObject = function(key, cn, val) {
  var Def, instance;

  Def = getObjectForDefinitionAndKey(this._objectDefinition, cn);

  instance = new Def();
  instance.fromDb(key, cn, val);
  return instance;
};

/**
 * Get all objects over a key, this is fairly awesome, because it makes some
 * assumptions but it also has a set of limitations.
 *
 * 1) It iterates using the normal BaseObjectIterator `getSliceByKey` and then also uses
 * a `getSliceByKey` call for the parent It then keeps two queues which are in
 * lexical order then comparing and parsing through them.  It uses string
 * comparisons which assume that they are in order.
 *
 * *Note: that detail is key*
 *
 * Once it finds a double match it emits an object, so it's only memory bound by
 * the biggest gap between the two.
 *
 * @param {String} key the key to work on.
 * @param {Object} objDef the definition of the object.
 * @param {Boolean} noIncludeChildren whether to prevent including children.
 * @param {String} starting the prefix to filter on.
 *
 */
BaseObjectIterator.prototype.getSliceByKeyWithParent = function(key, objDef, noIncludeChildren, starting) {
  var parentIterOptions = misc.merge(this._options, {dataPrefix: objDef.meta.dataPrefix}),
      currentIter = new BaseObjectIterator(this._ctx, this._objectDefinition, this._options),
      parentIter = new BaseObjectIterator(this._ctx, objDef, parentIterOptions),
      self = this,
      cQueue = [],
      pQueue = [],
      child,
      parent;

  parentIter.getSliceByKey(key, noIncludeChildren, starting);
  currentIter.getSliceByKey(key, noIncludeChildren, starting);

  function matchAndPop(pQueue, cQueue) {
    while (pQueue.length && cQueue.length) {
      while (pQueue.length && pQueue[0].key < cQueue[0].parentKey()) {
        pQueue.shift();
      }
      if (pQueue.length) {
        child = cQueue.shift();
        // Assign to something better like entity or something
        child.parent = pQueue[0];
        self.total++;
        self._emitObject(child);
      }
    }
  }

  parentIter.on('object', function(obj) {
    pQueue.push(obj);
    matchAndPop(pQueue, cQueue);
  });

  currentIter.on('object', function(obj) {
    cQueue.push(obj);
    matchAndPop(pQueue, cQueue);
  });

  async.forEach([parentIter, currentIter], function(e, callback) {
    // Ignore the data passed by end event
    e.on('end', callback.bind(null, null));
  },
  function() {
    // When this is reached, all emitters have ended
    self._emitEnd();
  });

  // Error on any error
  [parentIter, currentIter].forEach(function(e) {
    e.on('error', function(err) {
      self._emitError(err);
    });
  });
};

/**
 * Create a new index iterator that is meant for retrieving indexes. The object
 * definition that you pass in is based off the definition on the object type
 * you'd like to access. In an example case, we have a BoundCheck which has a
 * secondary index (collectorId) -> (acctId:entityId:checkId:bcId), this index
 * is named "collector_idx." It returns back a list of objects referenced by
 * the index but stored in a native columnFamily.
 *
 * It basically works by using the "ColumnList", ones that take list of columns
 * not slices, family of calls to build a set of calls from the index.  So the
 * initial index call gets a list of ids back something looking like this:
 *
 * (acctId:entityId:checkId:bcId), it then knows to make the first tuple back to
 * the row key (by the index definition) and uses the rest to build a list of
 * columns to pull, it then creates a single get based on the likeness of keys.
 *
 * We pass in noRelationships = false so it does the following to the keys
 *
 * ['enA:chB:bcA', 'enA:chB:bcD'] -> ['_enA', 'enA:chB', 'enA:chB:bcA', '_enA',
 * 'enA:chB', 'enA:chB:bcD']
 *
 * *Note: This could be optimized further in the future*
 *
 * Order is important on how the iterator works right now.  It uses a
 * incremental approach that only works with a sorted set of items, this will
 * probably remain this way for the near future.
 *
 * @constructor
 * @param {DbObjectContext} ctx the context to use.
 * @param {Object} objectDefinition the object definition of the data mapping
 *        relationship.
 * @param {?String} key Row key of the object to which the index points to
 * (optional, only used if index is scoped to the row key).
 * @param {Object} options the hash of options to pass in.
 */
var IndexIterator = function(ctx, objectDefinition, key, options) {
  options = options || {};
  this._ctx = ctx;
  this._objectDefinition = objectDefinition;
  this._key = key;
  this._options = options || {};
  this._writeConsistency = options.writeConsistency || settings.DEFAULT_WRITE_CONSISTENCY;

  this.total = 0;
  BaseIterator.call(this, ctx);
};

util.inherits(IndexIterator, BaseIterator);

/**
 * Get the column names for an array of keys from the index.
 * @param {String} indexName The name of the index to search with.
 * @param {Array} indexKeys Array of keys in the index to look up.
 * @param {?Object} options Optional options object.
 */
IndexIterator.prototype.getKeysFromIndex = function(indexName, indexKeys, options) {
  var idx = this._objectDefinition.meta.indexes[indexName],
      columnIterOptions,
      ci,
      self = this,
      count = 0;

  if (!idx) {
    throw new Error('Index does not exist! ' + indexName);
  }

  if (idx.scopeToObjectRowKey) {
    if (!this._key) {
      throw new Error('Index is scoped to a row key, but the row key wasn\'t provided');
    }
    // prepend row key to each index key
    indexKeys = indexKeys.map(function(key) {
      return compoundColumn([self._key, key]);
    });
  }

  function getObjectKey(name) {
    // $OBJKEY is always the last parameter of an index name
    var exploded = explodeColumn(name);
    return exploded[exploded.length - 1];
  }

  columnIterOptions = misc.merge(this._options, {dataPrefix: idx.meta.dataPrefix});
  ci = new ColumnIterator(this._ctx, idx.meta.columnFamily, columnIterOptions);
  this._addChildIterator(ci);

  ci.getSlice(indexKeys, options);

  ci.on('column', function(col) {
    self.emit('key', getObjectKey(col.name));
  });

  ci.on('end', function(col) {
    self._emitEnd();
  });

  ci.on('error', function(err) {
    self._emitError(err);
  });
};

/**
 * Get an index from an object definition. This corresponds to the name given to
 * the index on the meta attribute. This is in place of a query planner where it
 * would just figure it out =).
 *
 * @param {String} indexName the name of the index to search with.
 * @param {String} key the key to use for search.
 * @param {?Object} options Optional options object.
 */
IndexIterator.prototype.getIndex = function(indexName, key, options) {
  options = options || {};
  var columnIter,
      self = this,
      keyCols,
      keyPart,
      val,
      q,
      emitObj,
      obj,
      idx,
      rowKey,
      columnIterOptions,
      starting, ending,
      colNameConverter = makeColNameConverter(this._objectDefinition, true);

  idx = this._objectDefinition.meta.indexes[indexName];

  if (!idx) {
    throw new Error('Index does not exist! ' + indexName);
  }

  if (idx.scopeToObjectRowKey && !this._key) {
    throw new Error('Index is scoped to a row key, but the row key wasn\'t provided');
  }

  rowKey = getIndexRowKey(this._key, idx, key);

  columnIterOptions = misc.merge(this._options, {dataPrefix: idx.meta.dataPrefix});
  columnIter = new ColumnIterator(this._ctx, idx.meta.columnFamily, columnIterOptions);
  self._addChildIterator(columnIter);


  if (idx.relationship === 'ScopedOneToMany') {
    starting = key + INDEX_KEY_DELIM;
    ending = key + INDEX_KEY_DELIM + END_TOKEN;

    if (options.starting) {
      options.starting = starting + options.starting;
      options.ending = ending;
    }
    else {
      options.starting = starting;
      options.ending = ending;
    }

    columnIter.getSlice([rowKey], options);
  }
  else {
    options.colNameConverter = makeColNameConverter(idx, false);
    columnIter.getSlice([rowKey], options);
  }

  q = async.queue(function(task, callback) {
    if (task._lastCol) {
      self._emitEnd();
    }
    else {
      self._doIndexLookup(task.idx, task.emitObj, callback);
    }
  }, 1);

  columnIter.on('column', function(col) {
    var colName = col.name;

    // Object looks something like this:
    // { value: '{'label':234,'account_id':'aFoo','ip_addresses':null,'metadata':null}', name: '_en0BLL1iAp' }

    if (idx.relationship === 'ScopedOneToMany') {
      colName = col.name.split(INDEX_KEY_DELIM)[1];
    }

    keyCols = colNameConverter(colName);
    keyPart = keyCols[idx._rowKeyPosition];
    val = keyCols.slice(idx._rowKeyPosition + 1);

    // Start at the depth of the column definition for which this iterator was
    // created if the key hasn't been tracked yet
    if (!obj || obj.name !== keyPart) {
      emitObj = obj;
      obj = { name: keyPart, value: [], indexRowKey: key };
      // Emit at the end of a new object not the beginning, if we wanted the
      // beginning we would emit 'obj'
      if (emitObj) {
        q.push({ idx: idx, emitObj: emitObj});
      }
    }
    obj.value.push({
      id: val,
      indexColumn: col.name
    });
  });

  columnIter.on('error', function(err) {
    self._emitError(err);
  });

  columnIter.on('end', function(err) {
    if (obj) {
      q.push({ idx: idx, emitObj: obj});
    }

    q.push({'_lastCol': true});
  });
};

/**
 * Perform a select on the rowKey, in the context of a full index lookup.
 * @param {Object} idx the index definition.  idx has a meta attribute exactly
 *                 like how a native object type does.  This simplifies the
 *                 object definition considerably, since it only requires a
 *                 single interface.
 * @param {Object} emitContext Do the lookup on a set of this object.
 * @param {Function} callback the callback to call upon completion of the index
 *                   Lookup.
 */
IndexIterator.prototype._doIndexLookup = function(idx, emitContext, callback) {
  var objIter = new BaseObjectIterator(this._ctx, registry[idx.object], this._options),
      self = this,
      received = {}, // this is a hash set
      receivedCount = 0,
      columns;

  columns = emitContext.value.map(function(value) {
    return value.id;
  });

  objIter.getColumnListByKey(emitContext.name, columns);

  objIter.on('object', function(obj) {
    self.total++;
    receivedCount++;
    received[obj.getColumnName()] = true;
    self._emitObject(obj);
  });

  objIter.on('error', function(err) {
    callback(err);
  });

  objIter.on('end', function() {
    if (self._options.clean && columns.length > receivedCount) {
      log.warn('IndexIterator received less objects than it requested, attempting index cleanup', {
        ctx: self._ctx,
        expected: columns.length,
        received: receivedCount
      });
      self._doIndexCleanup(idx, emitContext, receivedCount, received, callback);
    } else if (columns.length < receivedCount) {
      log.error('IndexIterator received more objects than it requested', {
        ctx: self._ctx,
        expected: columns.length,
        received: receivedCount
      });
      callback();
    } else {
      callback();
    }
  });
};

/**
 * Given a set of columns pointed to by an index, and the set of columns
 * actually received from the database, go find columns that are indexed, but
 * don't actually exist, and remove them from the index.
 * @param {Object} idx The index metadata.
 * @param {Object} emitContext The bizarrely named object with data from the index.
 * @param {Integer} receivedCount The number of objects in the received set.
 * @param {Object} received A 'hash set' of column names actually received.
 * @param {Function} callback A callback fired upon completion.
 */
IndexIterator.prototype._doIndexCleanup = function(idx, emitContext, receivedCount, received, callback) {
  var self = this,
      remove = [],
      shouldRemove = emitContext.value.length - receivedCount,
      qmarks, query, args;

  // Iterate the set of expected columns and look for ones we didn't actually
  // receive. For such columns, we know the corresponding column in the index,
  // so record it for deletion
  emitContext.value.forEach(function(value) {
    // These look like:
    // {
    //   id: ['enPOJAeFBR', 'chotS0wPbL', 'bcd9j2GtYN'],
    //   indexColumn: 'aFoo:enPOJAeFBR:chotS0wPbL:bcd9j2GtYN'
    // }
    if (!received[self._objectDefinition.dataPrefix() + compoundColumn(value.id)]) {
      remove.push(value.indexColumn);
    }
  });

  // Additional validation to be really sure this is a good idea
  if (settings.INDEX_CLEANUP_WHITELIST.indexOf(self._objectDefinition.meta.cname) === -1) {
    log.info('skipping index cleanup for non-whitelisted object', {
      ctx: self._ctx,
      type: self._objectDefinition.meta.cname,
      shouldRemove: shouldRemove,
      wouldRemove: remove.length,
      indexKey: emitContext.indewRowKey,
      indexCF: idx.columnFamily
    });
    callback();
    return;
  } else if (remove.length !== shouldRemove) {
    log.error('index cleanup would remove incorrect number of columns, cancelling', {
      ctx: self._ctx,
      shouldRemove: shouldRemove,
      wouldRemove: remove.length,
      indexKey: emitContext.indewRowKey,
      indexCF: idx.columnFamily
    });
    callback();
    return;
  }

  qmarks = buildPlaceholderString(remove.length);

  log.warn('deleting dangling columns from index', {
    ctx: self._ctx,
    columnCount: remove.length,
    indexKey: emitContext.indewRowKey,
    indexCF: idx.columnFamily
  });

  query = 'DELETE ' + qmarks + ' FROM ? USING CONSISTENCY ' + this._writeConsistency + ' WHERE KEY=?';
  args = remove.concat(idx.columnFamily, emitContext.indexRowKey);

  getConnPool().execute(self._ctx, query, args, function(err, result) {
    // There isn't a ton we can do about errors here, its probably best to just keep going
    if (err) {
      log.error('database error during index cleanup, ignoring', {
        ctx: self._ctx,
        columnCount: remove.length,
        indexKey: emitContext.indewRowKey,
        indexCF: idx.columnFamily,
        err: err
      });
    } else {
      log.info('successful removal of dangling index columns', {
        ctx: self._ctx,
        columnCount: remove.length,
        indexKey: emitContext.indewRowKey,
        indexCF: idx.columnFamily

      });
    }
    callback();
  });
};

/**
 * A new base object iterator that handles filtering objects.
 *
 * @constructor
 * @param {DbOperationContext} ctx the context which to create.
 * @param {DBBase} objectDefinition the object definition to iterate on.
 * @param {Object} options the options dict.
 * @param {Object} filters the hash of named filters.
 */
var FilteredObjectIterator = function(ctx, objectDefinition, options, filters) {
  BaseObjectIterator.call(this, ctx, objectDefinition, options);
  this._filters = filters || {};
};

util.inherits(FilteredObjectIterator, BaseObjectIterator);

/**
 * Add a new filter.
 *
 * @param {String} name Filter name.
 * @param {String} filterFunc Filter function which gets passed an object as the
 *                 first argument and should return true if the 'object' event
 *                 should be emitted for this object.
 */
FilteredObjectIterator.prototype.addFilter = function(name, filterFunc) {
  if (this._filters.hasOwnProperty(name)) {
    throw new Error(sprintf('Filter %s already exists', name));
  }

  this._filters[name] = filterFunc;
};

/**
 * Remove a filter.
 *
 * @param {String} name Filter name.
 *
 */
FilteredObjectIterator.prototype.removeFilter = function(name) {
  if (!this._filters.hasOwnProperty(name)) {
    throw new Error(sprintf('Filter does not %s exists', name));
  }

  delete this._filters[name];
};

/**
 * Run all the filters and determines if the object should be included in the
 * resulting set
 *
 * @param {Function} obj Object to check.
 * @return {Boolean} true if the object should be included, false otherwise.
 */
FilteredObjectIterator.prototype._includeObject = function(obj) {
  var k;

  for (k in this._filters) {
    if (this._filters.hasOwnProperty(k) && !this._filters[k](obj)) {
      return false;
    }
  }

  return true;
};

/**
 * Emit an 'object' event.
 *
 * @param {DBBase} obj Object to emit.
 * @return {Boolean} true if the object has been emitted, false otherwise.
 */
FilteredObjectIterator.prototype._emitObject = function(obj) {
  if (!this._includeObject(obj)) {
    return false;
  }

  this.emit('object', obj);
  return true;
};

/**
* Object iterator which filters out deleted objects.
 *
 * @constructor
 * @param {DbObjectContext} ctx the context to use.
 * @param {Object} objectDefinition the object definition of the data mapping
 *        relationship.
 * @param {Object} options the hash of options to pass in.
 */
var ObjectIterator = function(ctx, objectDefinition, options) {
  options = options || {};
  var filters = {
    deleted_objects: ObjectIterator._isNotDeleted.bind(this)
  };
  filters = misc.merge(filters, options.filters || {});

  FilteredObjectIterator.call(this, ctx, objectDefinition, options, filters);
};

util.inherits(ObjectIterator, FilteredObjectIterator);

/**
 * Determines if the object has not been deleted.
 *
 * @param {DBBase} obj Object to emit.
 * @return {Boolean} true if the object is deleted, false otherwise.
 */
ObjectIterator._isNotDeleted = function(obj) {
  if (!obj.hasOwnProperty(REMOVED_FIELD)) {
    return true;
  }

  if (obj[REMOVED_FIELD]) {
    return false;
  }

  return true;
};

/**
 * Paginated Iterator
 * @constructor
 * @param {DbOperationContext} ctx The context to pass in.
 * @param {Defs} objectDefinition Object Definition.
 * @param {?Object} options Options.
 */
var PaginatedIterator = function(ctx, objectDefinition, options) {
  var batchSize;
  options = options || {};
  BaseIterator.call(this, ctx);

  this._objectDefinition = objectDefinition;
  this._limit = options.limit || null;
  if (options.batchSize) {
    // if a batch size is specified use it
    batchSize = options.batchSize;
  } else if (this._limit) {
    // else if a limit is specified, multiply by the object's batch size
    // Note: to increase the changes that this can complete in a single query
    // we add 1 which we need for the marker and 1 to cause the object iterator
    // to flush.
    batchSize = Math.min(this._limit * objectDefinition.batchSizeMultiplier(), 1000) + 2;
  } else {
    // else don't specify a batch size, let ColumnIterator use its own default
    batchSize = undefined;
  }
  this._options = misc.merge(options, {batchSize: batchSize});
  this._counter = 0;
  this.total = 0;
};

util.inherits(PaginatedIterator, BaseIterator);

/**
 * Paginate on an iterator.
 * @param {Object} iter The iterator to "paginate" on.
 */
PaginatedIterator.prototype._paginate = function(iter) {
  var self = this,
      overflown = false,
      received = 0,
      previous = null;

  iter.on('object', function onObj(obj) {
    received++;

    // Limit has been reached, we aren't interested in any more objects.
    // Note: trying to use the 'total' property of the underlying iterator
    // doesn't work very well since some iterators increment it after emitting
    // and others increment it before. We just track it ourselves instead.
    if (self._limit && (received > self._limit)) {
      overflown = true;
      self.close();
      iter.removeAllListeners('object');
    }

    // We never emit an object until the next one has been received (its child
    // relationships aren't built yet otherwise).
    if (previous !== null) {
      self._emitObjectAndIncrementTotal(previous);
    }

    previous = obj;
  });

  iter.on('end', function onEnd(data) {
    var nextKey;

    // We have one object that has not yet been emitted. If we are past the
    // specified limit we pass back the key to that object as the "next"
    // object, otherwise, we emit the object.
    if (overflown) {
      nextKey = self._constructKeyForNextObj(previous);
    } else if (previous !== null) {
      self._emitObjectAndIncrementTotal(previous);
    }

    self._emitEnd({'nextKey': nextKey});
  });

  iter.on('error', function onErr(err) {
    self._emitError(err);
  });
};

/**
 * Construct a key which can be used for a 'marker'.
 *
 * @param {Object} nextObj Object (must include parents).
 * @return {String} Constructs a full key for the next object.
 */
PaginatedIterator.prototype._constructKeyForNextObj = function(nextObj) {
  return nextObj.getKey();
};

/**
 * Paginated Object Iterator
 * @constructor
 * @param {DbOperationContext} ctx The context to pass in.
 * @param {Defs} objectDefinition Object Definition.
 * @param {?Object} options Options.
 */
var PaginatedObjectIterator = function(ctx, objectDefinition, options) {
  PaginatedIterator.call(this, ctx, objectDefinition, options);
};

util.inherits(PaginatedObjectIterator, PaginatedIterator);

/**
 * Get all objects over a slice.
 * @param {String} key Key of the object to retrieve.
 * @param {Boolean} includeChildren true to include building the children relationships.
 * @param {String} starting column prefix to start slicing on.
 * @param {String} ending (optional) slice to end with. If not present starting is treated as a wildcard.
 */
PaginatedObjectIterator.prototype.getSliceByKey = function(key, includeChildren, starting, ending) {
  this._getSlice(key, includeChildren, starting, ending);
};

/**
 * Get all objects over a slice.
 * @param {Boolean} includeChildren true to include building the children relationships.
 * @param {String} starting column prefix to start slicing on.
 * @param {String} ending (optional) slice to end with. If not present starting is treated as a wildcard.
 */
PaginatedObjectIterator.prototype.getSlice = function(includeChildren, starting, ending) {
  this._getSlice(null, includeChildren, starting, ending);
};

/**
 * Get all objects over a slice.
 * @param {?String} key Optional key of the object to retrieve.
 * @param {Boolean} includeChildren true to include building the children relationships.
 * @param {String} starting column prefix to start slicing on.
 * @param {String} ending (optional) slice to end with. If not present starting is treated as a wildcard.
 */
PaginatedObjectIterator.prototype._getSlice = function(key, includeChildren, starting, ending) {
  var iter = new ObjectIterator(this._ctx, this._objectDefinition, this._options);
  this._addChildIterator(iter);

  // Register event handlers.
  this._paginate(iter);

  process.nextTick(function() {
    if (key) {
      iter.getSliceByKey(key, !includeChildren, starting, ending);
    } else {
      iter.getSlice(!includeChildren, starting, ending);
    }
  });
};

/**
 * Paginated Index Iterator.
 * @constructor
 * @param {DbOperationContext} ctx The context for this operation.
 * @param {Object} objectDefinition Object Definition.
 * @param {?String} key Row key of the object to which the index points to.
 * @param {?Object} options Options hash.
 */
var PaginatedIndexIterator = function(ctx, objectDefinition, key, options) {
  this._key = key;
  PaginatedIterator.call(this, ctx, objectDefinition, options);
};

util.inherits(PaginatedIndexIterator, PaginatedIterator);

/**
 * Iterate an index using pagination.
 * @param {String} indexName The name of the index to iterate.
 * @param {String} key The key to look up in the index.
 * @param {Object} options An options object.
 */
PaginatedIndexIterator.prototype.getIndex = function(indexName, key, options) {
  var iter = new IndexIterator(this._ctx, this._objectDefinition, this._key, this._options);
  this._addChildIterator(iter);

  iter.getIndex(indexName, key, options);
  this._paginate(iter);
};

/**
 * Indexes prepend the row key to the normal object key.
 * @param {Object} nextObj The object we should generate a key for.
 * @return {String} The key to nextObj.
 */
PaginatedIndexIterator.prototype._constructKeyForNextObj = function(nextObj) {
  var parents = this._objectDefinition.parents(),
      keyParts = [nextObj.getRowKey()],
      i, len, parentKeyString, parentKey;

  for (i = 0, len = parents.length; i < len; i++) {
    parentKeyString = parents[i];
    parentKey = nextObj[parentKeyString];
    keyParts.push(parentKey);
  }

  keyParts.push(nextObj.getKey());
  return compoundColumn(keyParts);
};


/**
 * An iterator that emits row keys for a column family.
 * @constructor
 * @param {DbOperationContext} ctx The context of this iterator.
 * @param {String} cf The column family name to iterate.
 * @param {?Object} options Options including 'batchSize' and 'readConsistency'.
 */
function RowKeyIterator(ctx, cf, options) {
  BaseIterator.call(this, ctx);
  options = options || {};
  this._cf = cf;
  this._batchSize = options.batchSize || 10000;
  this._readConsistency = options.readConsistency || settings.DEFAULT_READ_CONSISTENCY;
}

util.inherits(RowKeyIterator, BaseIterator);


/**
 * Iterate all row keys.
 */
RowKeyIterator.prototype.getKeys = function() {
  var self = this, resultCount, lastKey;

  async.until(
    function isDone() {
      return (self._closed || resultCount < self._batchSize);
    },

    function performQuery(callback) {
      var query = 'SELECT KEY FROM ?',
          args = [self._cf];

      query += ' USING CONSISTENCY ' + self._readConsistency;

      if (lastKey) {
        query += ' WHERE KEY > ?';
        args.push(lastKey);
      }

      query += ' LIMIT ' + self._batchSize;

      getConnPool().execute(self._ctx, query, args, function(err, result) {
        if (err) {
          callback(err);
          return;
        }

        resultCount = result.rowCount();

        if (resultCount > 0) {
          lastKey = result[resultCount - 1].key;
        }

        result.forEach(function(row) {
          self.emit('key', row.key);
        });

        callback();
      });
    },

    function whenDone(err) {
      if (err) {
        self._emitError(err);
      } else {
        self._emitEnd();
      }
    }
  );
};


/**
 * Base iterator class. Should never really be instantiated manually.
 */
exports.BaseIterator = BaseIterator;

/**
 * Base object iterator class which performs no filtering.
 */
exports.BaseObjectIterator = BaseObjectIterator;

/**
 * Export the index iterator, use it externally and internally.
 */
exports.IndexIterator = IndexIterator;

/**
 * Iterator which applies filtering functions on the object before emitting an
 * event. 'object' event is only emitted for the objects which are not filtered
 * out by the filtering functions.
 */
exports.FilteredObjectIterator = FilteredObjectIterator;

/**
 * Export the column iterator, the interface for iterating over columns.
 */
exports.ColumnIterator = ColumnIterator;

/**
 * Export the row iterator, the interface for iterating over rows.
 */
exports.RowPaginatedIndexIterator = RowPaginatedIndexIterator;

/**
 * Export the object iterator, the interface for iterating over columns and
 * generating columns out of that. It also filters out deleted objects.
 */
exports.ObjectIterator = ObjectIterator;

/** PaginatedObjectIterator class. */
exports.PaginatedObjectIterator = PaginatedObjectIterator;

/** PaginatedIndexIterator class. */
exports.PaginatedIndexIterator = PaginatedIndexIterator;

/** RowKeyIterator class. */
exports.RowKeyIterator = RowKeyIterator;
